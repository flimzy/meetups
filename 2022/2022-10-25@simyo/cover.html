
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>bstore: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/mjl-/bstore/default.go (88.9%)</option>
				
				<option value="file1">github.com/mjl-/bstore/equal.go (84.6%)</option>
				
				<option value="file2">github.com/mjl-/bstore/exec.go (87.9%)</option>
				
				<option value="file3">github.com/mjl-/bstore/export.go (82.3%)</option>
				
				<option value="file4">github.com/mjl-/bstore/keys.go (87.9%)</option>
				
				<option value="file5">github.com/mjl-/bstore/nonzero.go (84.2%)</option>
				
				<option value="file6">github.com/mjl-/bstore/pack.go (93.8%)</option>
				
				<option value="file7">github.com/mjl-/bstore/parse.go (83.5%)</option>
				
				<option value="file8">github.com/mjl-/bstore/plan.go (93.6%)</option>
				
				<option value="file9">github.com/mjl-/bstore/query.go (88.6%)</option>
				
				<option value="file10">github.com/mjl-/bstore/register.go (90.7%)</option>
				
				<option value="file11">github.com/mjl-/bstore/stats.go (100.0%)</option>
				
				<option value="file12">github.com/mjl-/bstore/store.go (91.1%)</option>
				
				<option value="file13">github.com/mjl-/bstore/tags.go (100.0%)</option>
				
				<option value="file14">github.com/mjl-/bstore/tx.go (89.2%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package bstore

import (
        "fmt"
        "reflect"
        "time"
)

var zerotime = time.Time{}

// applyDefault replaces zero values for fields that have a Default value configured.
func (tv *typeVersion) applyDefault(rv reflect.Value) error <span class="cov8" title="1">{
        for _, f := range tv.Fields[1:] </span><span class="cov8" title="1">{
                fv := rv.FieldByIndex(f.structField.Index)
                if err := f.applyDefault(fv); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (f field) applyDefault(rv reflect.Value) error <span class="cov8" title="1">{
        switch f.Type.Kind </span>{
        case kindBytes, kindBinaryMarshal, kindMap:<span class="cov8" title="1">
                return nil</span>

        case kindSlice, kindStruct:<span class="cov8" title="1">
                return f.Type.applyDefault(rv)</span>

        case kindBool, kindInt, kindInt8, kindInt16, kindInt32, kindInt64, kindUint, kindUint8, kindUint16, kindUint32, kindUint64, kindFloat32, kindFloat64, kindString, kindTime:<span class="cov8" title="1">
                if !f.defaultValue.IsValid() || !rv.IsZero() </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov8" title="1">fv := f.defaultValue
                // Time is special. "now" is encoded as the zero value of time.Time.
                if f.Type.Kind == kindTime &amp;&amp; fv.Interface() == zerotime </span><span class="cov8" title="1">{
                        now := time.Now().Round(0)
                        if f.Type.Ptr </span><span class="cov8" title="1">{
                                fv = reflect.ValueOf(&amp;now)
                        }</span> else<span class="cov8" title="1"> {
                                fv = reflect.ValueOf(now)
                        }</span>
                } else<span class="cov8" title="1"> if f.Type.Ptr </span><span class="cov8" title="1">{
                        fv = reflect.New(f.structField.Type.Elem())
                        fv.Elem().Set(f.defaultValue)
                }</span>
                <span class="cov8" title="1">rv.Set(fv)
                return nil</span>

        default:<span class="cov0" title="0">
                return fmt.Errorf("internal error: missing case for %v", f.Type.Kind)</span>
        }
}

// only for recursing. we do not support recursing into maps because it would
// involve more work making values settable. and how sensible it it anyway?
func (ft fieldType) applyDefault(rv reflect.Value) error <span class="cov8" title="1">{
        if ft.Ptr &amp;&amp; (rv.IsZero() || rv.IsNil()) </span><span class="cov8" title="1">{
                return nil
        }</span> else<span class="cov8" title="1"> if ft.Ptr </span><span class="cov8" title="1">{
                rv = rv.Elem()
        }</span>
        <span class="cov8" title="1">switch ft.Kind </span>{
        case kindSlice:<span class="cov8" title="1">
                n := rv.Len()
                for i := 0; i &lt; n; i++ </span><span class="cov8" title="1">{
                        if err := ft.List.applyDefault(rv.Index(i)); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        case kindStruct:<span class="cov8" title="1">
                for _, nf := range ft.Fields </span><span class="cov8" title="1">{
                        nfv := rv.FieldByIndex(nf.structField.Index)
                        if err := nf.applyDefault(nfv); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package bstore

import (
        "bytes"
        "encoding"
        "reflect"
        "time"
)

// equal checks if ov and v are the same as far as storage is concerned. i.e.
// this only takes stored fields into account. reflect.DeepEqual cannot be used,
// it would take all fields into account, including unexported.
func (tv *typeVersion) equal(ov, v reflect.Value) (r bool) <span class="cov8" title="1">{
        if !ov.IsValid() || !v.IsValid() </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">for _, f := range tv.Fields </span><span class="cov8" title="1">{
                fov := ov.FieldByIndex(f.structField.Index)
                fv := v.FieldByIndex(f.structField.Index)
                if !f.Type.equal(fov, fv) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

func (ft fieldType) equal(ov, v reflect.Value) (r bool) <span class="cov8" title="1">{
        if ov == v </span><span class="cov8" title="1">{
                return true
        }</span> else<span class="cov8" title="1"> if !ov.IsValid() || !v.IsValid() </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if ft.Ptr </span><span class="cov8" title="1">{
                ov = ov.Elem()
                v = v.Elem()
        }</span>
        <span class="cov8" title="1">if ov == v </span><span class="cov8" title="1">{
                return true
        }</span> else<span class="cov8" title="1"> if !ov.IsValid() || !v.IsValid() </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">switch ft.Kind </span>{
        case kindBytes:<span class="cov8" title="1">
                return bytes.Equal(ov.Bytes(), v.Bytes())</span>
        case kindMap:<span class="cov8" title="1">
                on := ov.Len()
                n := v.Len()
                if on != n </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov8" title="1">r := ov.MapRange()
                for r.Next() </span><span class="cov8" title="1">{
                        vv := v.MapIndex(r.Key())
                        if !vv.IsValid() || !ft.MapValue.equal(r.Value(), vv) </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
                <span class="cov8" title="1">return true</span>
        case kindSlice:<span class="cov8" title="1">
                on := ov.Len()
                n := v.Len()
                if on != n </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov8" title="1">for i := 0; i &lt; n; i++ </span><span class="cov8" title="1">{
                        if !ft.List.equal(ov.Index(i), v.Index(i)) </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
                <span class="cov8" title="1">return true</span>
        case kindTime:<span class="cov8" title="1">
                return ov.Interface().(time.Time).Equal(v.Interface().(time.Time))</span>
        case kindBinaryMarshal:<span class="cov8" title="1">
                obuf, oerr := ov.Interface().(encoding.BinaryMarshaler).MarshalBinary()
                buf, err := v.Interface().(encoding.BinaryMarshaler).MarshalBinary()
                if oerr != nil || err != nil </span><span class="cov0" title="0">{
                        return false // todo: should propagate error?
                }</span>
                <span class="cov8" title="1">return bytes.Equal(obuf, buf)</span>
        case kindStruct:<span class="cov8" title="1">
                for _, f := range ft.Fields </span><span class="cov8" title="1">{
                        fov := ov.FieldByIndex(f.structField.Index)
                        fv := v.FieldByIndex(f.structField.Index)
                        if !f.Type.equal(fov, fv) </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
                <span class="cov8" title="1">return true</span>
        }
        <span class="cov8" title="1">return ov.Interface() == v.Interface()</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package bstore

import (
        "bytes"
        "fmt"
        "reflect"
        "sort"
        "time"

        bolt "github.com/etcd-io/bbolt"
)

// exec represents the execution of a query plan.
type exec[T any] struct {
        q    *Query[T]
        plan *plan[T]

        // For queries with explicit PKs filtered on.
        // See plan.keys. We remove items from the list when we looked one up, but we keep the slice non-nil.
        keys [][]byte

        // If -1, no limit is set. This is different from Query where 0 means
        // no limit. We count back and 0 means the end.
        limit int

        data    []pair[T] // If not nil (even if empty), serve nextKey requests from here.
        ib      *bolt.Bucket
        rb      *bolt.Bucket
        forward func() (bk, bv []byte) // Once we start scanning, we prepare forward to next/prev to the following value.
}

// exec creates a new execution for the plan, registering statistics.
func (p *plan[T]) exec(q *Query[T]) *exec[T] <span class="cov8" title="1">{
        q.stats.Queries++
        if p.idx == nil </span><span class="cov8" title="1">{
                if p.keys != nil </span><span class="cov8" title="1">{
                        q.stats.PlanPK++
                }</span> else<span class="cov8" title="1"> if p.start != nil || p.stop != nil </span><span class="cov8" title="1">{
                        q.stats.PlanPKScan++
                }</span> else<span class="cov8" title="1"> {
                        q.stats.PlanTableScan++
                }</span>
                <span class="cov8" title="1">q.stats.LastIndex = ""</span>
        } else<span class="cov8" title="1"> {
                if p.keys != nil </span><span class="cov8" title="1">{
                        q.stats.PlanUnique++
                }</span> else<span class="cov8" title="1"> {
                        q.stats.PlanIndexScan++
                }</span>
                <span class="cov8" title="1">q.stats.LastIndex = p.idx.Name</span>
        }
        <span class="cov8" title="1">if len(p.orders) &gt; 0 </span><span class="cov8" title="1">{
                q.stats.Sort++
        }</span>
        <span class="cov8" title="1">q.stats.LastOrdered = p.start != nil || p.stop != nil
        q.stats.LastAsc = !p.desc

        limit := -1
        if q.xlimit &gt; 0 </span><span class="cov8" title="1">{
                limit = q.xlimit
        }</span>
        <span class="cov8" title="1">return &amp;exec[T]{q: q, plan: p, keys: p.keys, limit: limit}</span>
}

// incr treats buf as a bigendian number, increasing it by one. used for reverse
// scans, where we must start beyond the key prefix we are looking for.
func incr(buf []byte) bool <span class="cov8" title="1">{
        for i := len(buf) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                if buf[i] &lt; 255 </span><span class="cov8" title="1">{
                        buf[i]++
                        return true
                }</span>
                <span class="cov8" title="1">buf[i] = 0</span>
        }
        <span class="cov8" title="1">return false</span>
}

func cutoff(b []byte, n int) []byte <span class="cov8" title="1">{
        if len(b) &lt;= n </span><span class="cov8" title="1">{
                return b
        }</span>
        <span class="cov8" title="1">return b[:n]</span>
}

// nextKey returns the key and optionally value for the next selected record.
//
// ErrAbsent is returned if there is no more record.
//
// If an error occurs, an error is set on query, except in the case of
// ErrAbsent. ErrAbsent does not finish the query because a Delete or Update
// could follow.
func (e *exec[T]) nextKey(write, value bool) ([]byte, T, error) <span class="cov8" title="1">{
        var zero T

        q := e.q

        if q.err != nil </span><span class="cov0" title="0">{
                return nil, zero, q.err
        }</span>

        // We collected &amp; sorted data previously. Return from it until done.
        // Limit was already applied.
        <span class="cov8" title="1">if e.data != nil </span><span class="cov8" title="1">{
                if len(e.data) == 0 </span><span class="cov8" title="1">{
                        return nil, zero, ErrAbsent
                }</span>
                <span class="cov8" title="1">p := e.data[0]
                e.data = e.data[1:]
                var v T
                if value </span><span class="cov8" title="1">{
                        var err error
                        v, err = p.Value(e)
                        if err != nil </span><span class="cov0" title="0">{
                                q.error(err)
                                return nil, zero, err
                        }</span>
                }
                <span class="cov8" title="1">return p.bk, v, nil</span>
        }

        <span class="cov8" title="1">if e.limit == 0 </span><span class="cov8" title="1">{
                return nil, zero, ErrAbsent
        }</span>

        // First time we are going to need buckets.
        <span class="cov8" title="1">if e.rb == nil </span><span class="cov8" title="1">{
                tx, err := q.tx(write)
                if err != nil </span><span class="cov0" title="0">{
                        q.error(err)
                        return nil, zero, err
                }</span>
                <span class="cov8" title="1">e.rb, err = tx.recordsBucket(q.st.Name, q.st.Current.fillPercent)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, zero, err
                }</span>
                <span class="cov8" title="1">if e.plan.idx != nil </span><span class="cov8" title="1">{
                        e.ib, err = tx.indexBucket(e.plan.idx)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, zero, err
                        }</span>
                }
        }

        // List of IDs (records) or full unique index equality match.
        // We can get the records/index value by a simple "get" on the key.
        <span class="cov8" title="1">if e.keys != nil </span><span class="cov8" title="1">{
                collect := len(e.plan.orders) &gt; 0
                if collect </span><span class="cov8" title="1">{
                        e.data = []pair[T]{} // Must be non-nil to get into e.data branch!
                }</span>
                <span class="cov8" title="1">for i, xk := range e.keys </span><span class="cov8" title="1">{
                        var bk, bv []byte

                        // For indices, we need look up the PK through the index.
                        if e.plan.idx != nil </span><span class="cov8" title="1">{
                                c := e.ib.Cursor()
                                q.stats.Index.Cursor++
                                bki, _ := c.Seek(xk)
                                if !bytes.HasPrefix(bki, xk) </span><span class="cov8" title="1">{
                                        continue</span>
                                }
                                // log.Printf("seek %x, bki %x", xk, bki)
                                <span class="cov8" title="1">bk = bki[len(xk):]</span>
                        } else<span class="cov8" title="1"> {
                                bk = xk
                        }</span>

                        // We don't need to fetch the full record now if it isn't needed by
                        // caller. It may be fetch below for more filters.
                        <span class="cov8" title="1">if value || e.plan.idx == nil </span><span class="cov8" title="1">{
                                q.stats.Records.Get++
                                bv = e.rb.Get(bk)
                                if bv == nil </span><span class="cov8" title="1">{
                                        if e.plan.idx != nil </span><span class="cov0" title="0">{
                                                return nil, zero, fmt.Errorf("%w: record with pk %x referenced through index %q not found", ErrStore, bk, e.plan.idx.Name)
                                        }</span>
                                        <span class="cov8" title="1">continue</span>
                                }
                        }
                        <span class="cov8" title="1">p := pair[T]{bk, bv, nil}
                        if ok, err := e.checkFilter(&amp;p); err != nil </span><span class="cov0" title="0">{
                                return nil, zero, err
                        }</span> else<span class="cov8" title="1"> if !ok </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">if collect </span><span class="cov8" title="1">{
                                e.data = append(e.data, p)
                                continue</span>
                        }

                        // Again, only fetch value if needed.
                        <span class="cov8" title="1">var v T
                        if value </span><span class="cov8" title="1">{
                                var err error
                                v, err = p.Value(e)
                                if err != nil </span><span class="cov0" title="0">{
                                        q.error(err)
                                        return nil, zero, err
                                }</span>
                        }

                        <span class="cov8" title="1">if e.limit &gt; 0 </span><span class="cov8" title="1">{
                                e.limit--
                        }</span>

                        <span class="cov8" title="1">e.keys = e.keys[i+1:]
                        return bk, v, nil</span>
                }
                <span class="cov8" title="1">if !collect </span><span class="cov8" title="1">{
                        return nil, zero, ErrAbsent
                }</span>
                // Restart, now with data.
                <span class="cov8" title="1">e.keys = [][]byte{}
                e.sort()
                if e.limit &gt; 0 &amp;&amp; len(e.data) &gt; e.limit </span><span class="cov8" title="1">{
                        e.data = e.data[:e.limit]
                }</span>
                <span class="cov8" title="1">return q.nextKey(write, value)</span>
        }

        // We are going to do a scan, either over the records or an index. We may have a start and stop key.
        <span class="cov8" title="1">collect := len(e.plan.orders) &gt; 0
        if collect </span><span class="cov8" title="1">{
                e.data = []pair[T]{} // Must be non-nil to get into e.data branch on function restart.
        }</span>
        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                var xk, xv []byte
                if e.forward == nil </span><span class="cov8" title="1">{
                        // First time we are in this loop, we set up a cursor and e.forward.

                        var c *bolt.Cursor
                        var statsKV *StatsKV
                        if e.plan.idx == nil </span><span class="cov8" title="1">{
                                c = e.rb.Cursor()
                                statsKV = &amp;q.stats.Records
                        }</span> else<span class="cov8" title="1"> {
                                c = e.ib.Cursor()
                                statsKV = &amp;q.stats.Index
                        }</span>
                        <span class="cov8" title="1">if !e.plan.desc </span><span class="cov8" title="1">{
                                e.forward = c.Next
                                if e.plan.start != nil </span><span class="cov8" title="1">{
                                        statsKV.Cursor++
                                        // If e.plan.start does not exist, seek will skip to the
                                        // next value after. Fine because this is ascending order.
                                        xk, xv = c.Seek(e.plan.start)
                                }</span> else<span class="cov8" title="1"> {
                                        statsKV.Cursor++
                                        xk, xv = c.First()
                                }</span>
                        } else<span class="cov8" title="1"> {
                                e.forward = c.Prev
                                if e.plan.start == nil </span><span class="cov8" title="1">{
                                        statsKV.Cursor++
                                        xk, xv = c.Last()
                                }</span> else<span class="cov8" title="1"> {
                                        start := make([]byte, len(e.plan.start))
                                        copy(start, e.plan.start)
                                        ok := incr(start)
                                        if !ok </span><span class="cov8" title="1">{
                                                statsKV.Cursor++
                                                // We were at the last representable value. So we simply start at the end.
                                                xk, xv = c.Last()
                                        }</span> else<span class="cov8" title="1"> {
                                                statsKV.Cursor++
                                                xk, xv = c.Seek(start)
                                                if xk == nil </span><span class="cov8" title="1">{
                                                        statsKV.Cursor++
                                                        xk, xv = c.Last()
                                                }</span>
                                                // We started at the value after where we were requested to start, so we have to
                                                // move until we find a matching key.
                                                // todo: we could take e.plan.stop into account (if set). right now we may be
                                                // seeking all the way to the front without ever seeing a match to stop.
                                                <span class="cov8" title="1">for xk != nil &amp;&amp; bytes.Compare(cutoff(xk, len(e.plan.start)), e.plan.start) &gt; 0 </span><span class="cov8" title="1">{
                                                        statsKV.Cursor++
                                                        xk, xv = e.forward()
                                                }</span>
                                        }
                                }
                        }
                } else<span class="cov8" title="1"> {
                        if e.plan.idx == nil </span><span class="cov8" title="1">{
                                q.stats.Records.Cursor++
                        }</span> else<span class="cov8" title="1"> {
                                q.stats.Index.Cursor++
                        }</span>
                        <span class="cov8" title="1">xk, xv = e.forward()</span>
                        // log.Printf("forwarded, %x %x", xk, xv)
                }

                <span class="cov8" title="1">if xk == nil </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov8" title="1">if e.plan.start != nil &amp;&amp; !e.plan.startInclusive &amp;&amp; bytes.HasPrefix(xk, e.plan.start) </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if e.plan.stop != nil </span><span class="cov8" title="1">{
                        cmp := bytes.Compare(cutoff(xk, len(e.plan.stop)), e.plan.stop)
                        if !e.plan.desc &amp;&amp; (e.plan.stopInclusive &amp;&amp; cmp &gt; 0 || !e.plan.stopInclusive &amp;&amp; cmp &gt;= 0) </span><span class="cov8" title="1">{
                                break</span>
                        } else<span class="cov8" title="1"> if e.plan.desc &amp;&amp; (e.plan.stopInclusive &amp;&amp; cmp &lt; 0 || !e.plan.stopInclusive &amp;&amp; cmp &lt;= 0) </span><span class="cov8" title="1">{
                                break</span>
                        }
                }

                <span class="cov8" title="1">var pk, bv []byte
                if e.plan.idx == nil </span><span class="cov8" title="1">{
                        pk = xk
                        bv = xv
                }</span> else<span class="cov8" title="1"> {
                        var err error
                        pk, _, err = e.plan.idx.parseKey(xk, false)
                        if err != nil </span><span class="cov0" title="0">{
                                q.error(err)
                                return nil, zero, err
                        }</span>
                }

                <span class="cov8" title="1">p := pair[T]{pk, bv, nil}
                if ok, err := e.checkFilter(&amp;p); err != nil </span><span class="cov0" title="0">{
                        return nil, zero, err
                }</span> else<span class="cov8" title="1"> if !ok </span><span class="cov8" title="1">{
                        continue</span>
                }
                //log.Printf("have kv, %x %x", p.bk, p.bv)
                <span class="cov8" title="1">var v T
                var err error
                if value </span><span class="cov8" title="1">{
                        v, err = p.Value(e)
                        if err != nil </span><span class="cov0" title="0">{
                                q.error(err)
                                return nil, zero, err
                        }</span>
                }
                <span class="cov8" title="1">if collect </span><span class="cov8" title="1">{
                        e.data = append(e.data, p)
                        continue</span>
                }
                <span class="cov8" title="1">if e.limit &gt; 0 </span><span class="cov8" title="1">{
                        e.limit--
                }</span>
                <span class="cov8" title="1">return p.bk, v, nil</span>
        }
        <span class="cov8" title="1">if !collect </span><span class="cov8" title="1">{
                return nil, zero, ErrAbsent
        }</span>
        // Restart, now with data.
        <span class="cov8" title="1">e.sort()
        if e.limit &gt; 0 &amp;&amp; len(e.data) &gt; e.limit </span><span class="cov8" title="1">{
                e.data = e.data[:e.limit]
        }</span>
        <span class="cov8" title="1">return e.nextKey(write, value)</span>
}

// checkFilter checks against the filters for the plan.
func (e *exec[T]) checkFilter(p *pair[T]) (rok bool, rerr error) <span class="cov8" title="1">{
        q := e.q

        for _, ff := range e.plan.filters </span><span class="cov8" title="1">{
                switch f := ff.(type) </span>{
                // note: filterIDs is not here, it is handled earlier to fetch records.
                case filterFn[T]:<span class="cov8" title="1">
                        v, err := p.Value(e)
                        if err != nil </span><span class="cov0" title="0">{
                                q.error(err)
                                return false, err
                        }</span>
                        <span class="cov8" title="1">if !f.fn(v) </span><span class="cov8" title="1">{
                                return
                        }</span>
                case filterEqual[T]:<span class="cov8" title="1">
                        v, err := p.Value(e)
                        if err != nil </span><span class="cov0" title="0">{
                                q.error(err)
                                return false, err
                        }</span>
                        <span class="cov8" title="1">rv := reflect.ValueOf(v)
                        frv := rv.FieldByIndex(f.field.structField.Index)
                        if !f.field.Type.equal(frv, f.rvalue) </span><span class="cov8" title="1">{
                                return
                        }</span>
                case filterNotEqual[T]:<span class="cov8" title="1">
                        v, err := p.Value(e)
                        if err != nil </span><span class="cov0" title="0">{
                                q.error(err)
                                return false, err
                        }</span>
                        <span class="cov8" title="1">rv := reflect.ValueOf(v)
                        frv := rv.FieldByIndex(f.field.structField.Index)
                        if f.field.Type.equal(frv, f.rvalue) </span><span class="cov8" title="1">{
                                return
                        }</span>
                case filterIn[T]:<span class="cov8" title="1">
                        v, err := p.Value(e)
                        if err != nil </span><span class="cov0" title="0">{
                                q.error(err)
                                return false, err
                        }</span>
                        <span class="cov8" title="1">rv := reflect.ValueOf(v)
                        frv := rv.FieldByIndex(f.field.structField.Index)
                        var have bool
                        for _, xrv := range f.rvalues </span><span class="cov8" title="1">{
                                if f.field.Type.equal(frv, xrv) </span><span class="cov8" title="1">{
                                        have = true
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">if !have </span><span class="cov8" title="1">{
                                return
                        }</span>
                case filterNotIn[T]:<span class="cov8" title="1">
                        v, err := p.Value(e)
                        if err != nil </span><span class="cov0" title="0">{
                                q.error(err)
                                return false, err
                        }</span>
                        <span class="cov8" title="1">rv := reflect.ValueOf(v)
                        frv := rv.FieldByIndex(f.field.structField.Index)
                        for _, xrv := range f.rvalues </span><span class="cov8" title="1">{
                                if f.field.Type.equal(frv, xrv) </span><span class="cov8" title="1">{
                                        return
                                }</span>
                        }
                case filterCompare[T]:<span class="cov8" title="1">
                        v, err := p.Value(e)
                        if err != nil </span><span class="cov0" title="0">{
                                q.error(err)
                                return false, err
                        }</span>
                        <span class="cov8" title="1">rv := reflect.ValueOf(v)
                        fv := rv.FieldByIndex(f.field.structField.Index)
                        cmp := compare(f.field.Type.Kind, fv, f.value)
                        switch </span>{
                        case cmp == 0 &amp;&amp; (f.op == opGreaterEqual || f.op == opLessEqual):<span class="cov8" title="1"></span>
                        case cmp &lt; 0 &amp;&amp; (f.op == opLess || f.op == opLessEqual):<span class="cov8" title="1"></span>
                        case cmp &gt; 0 &amp;&amp; (f.op == opGreater || f.op == opGreaterEqual):<span class="cov8" title="1"></span>
                        default:<span class="cov8" title="1">
                                return</span>
                        }
                default:<span class="cov0" title="0">
                        q.errorf("internal error: missing case for filter %T", ff)
                        return false, q.err</span>
                }
        }
        <span class="cov8" title="1">return true, nil</span>
}

// if type can be compared for filterCompare, eg for greater/less comparison.
func comparable(ft fieldType) bool <span class="cov8" title="1">{
        if ft.Ptr </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">switch ft.Kind </span>{
        case kindBytes, kindString, kindBool, kindInt8, kindInt16, kindInt32, kindInt64, kindInt, kindUint8, kindUint16, kindUint32, kindUint64, kindUint, kindFloat32, kindFloat64, kindTime:<span class="cov8" title="1">
                return true</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}

func compare(k kind, a, b reflect.Value) int <span class="cov8" title="1">{
        switch k </span>{
        case kindBytes:<span class="cov8" title="1">
                return bytes.Compare(a.Bytes(), b.Bytes())</span>

        case kindString:<span class="cov8" title="1">
                sa := a.String()
                sb := b.String()
                if sa &lt; sb </span><span class="cov8" title="1">{
                        return -1
                }</span> else<span class="cov8" title="1"> if sa &gt; sb </span><span class="cov8" title="1">{
                        return 1
                }</span>
                <span class="cov0" title="0">return 0</span>

        case kindBool:<span class="cov8" title="1">
                ba := a.Bool()
                bb := b.Bool()
                if !ba &amp;&amp; bb </span><span class="cov0" title="0">{
                        return -1
                }</span> else<span class="cov8" title="1"> if ba &amp;&amp; !bb </span><span class="cov8" title="1">{
                        return 1
                }</span>
                <span class="cov8" title="1">return 0</span>

        case kindInt8, kindInt16, kindInt32, kindInt64, kindInt:<span class="cov8" title="1">
                ia := a.Int()
                ib := b.Int()
                if ia &lt; ib </span><span class="cov8" title="1">{
                        return -1
                }</span> else<span class="cov8" title="1"> if ia &gt; ib </span><span class="cov8" title="1">{
                        return 1
                }</span>
                <span class="cov8" title="1">return 0</span>

        case kindUint8, kindUint16, kindUint32, kindUint64, kindUint:<span class="cov8" title="1">
                ia := a.Uint()
                ib := b.Uint()
                if ia &lt; ib </span><span class="cov8" title="1">{
                        return -1
                }</span> else<span class="cov8" title="1"> if ia &gt; ib </span><span class="cov8" title="1">{
                        return 1
                }</span>
                <span class="cov8" title="1">return 0</span>

        case kindFloat32, kindFloat64:<span class="cov8" title="1">
                fa := a.Float()
                fb := b.Float()
                if fa &lt; fb </span><span class="cov8" title="1">{
                        return -1
                }</span> else<span class="cov8" title="1"> if fa &gt; fb </span><span class="cov8" title="1">{
                        return 1
                }</span>
                <span class="cov0" title="0">return 0</span>

        case kindTime:<span class="cov8" title="1">
                ta := a.Interface().(time.Time)
                tb := b.Interface().(time.Time)
                if ta.Before(tb) </span><span class="cov0" title="0">{
                        return -1
                }</span> else<span class="cov8" title="1"> if ta.After(tb) </span><span class="cov8" title="1">{
                        return 1
                }</span>
                <span class="cov8" title="1">return 0</span>
        }
        // todo: internal error, cannot happen
        <span class="cov0" title="0">return 0</span>
}

func (e *exec[T]) sort() <span class="cov8" title="1">{
        // todo: We should check whether we actually need to load values. We're just
        // always it now for the time being because SortStableFunc isn't going to
        // give us a *pair (even though it could because of the slice) so we
        // couldn't set/cache the value T during sorting.
        q := e.q

        for i := range e.data </span><span class="cov8" title="1">{
                p := &amp;e.data[i]
                if p.value != nil </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">_, err := p.Value(e)
                if err != nil </span><span class="cov0" title="0">{
                        q.error(err)
                        return
                }</span>
        }

        <span class="cov8" title="1">sort.SliceStable(e.data, func(i, j int) bool </span><span class="cov8" title="1">{
                a := e.data[i]
                b := e.data[j]
                for _, o := range e.plan.orders </span><span class="cov8" title="1">{
                        ra := reflect.ValueOf(*a.value)
                        rb := reflect.ValueOf(*b.value)
                        rva := ra.FieldByIndex(o.field.structField.Index)
                        rvb := rb.FieldByIndex(o.field.structField.Index)
                        cmp := compare(o.field.Type.Kind, rva, rvb)
                        if cmp == 0 </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">return cmp &lt; 0 &amp;&amp; o.asc || cmp &gt; 0 &amp;&amp; !o.asc</span>
                }
                <span class="cov0" title="0">return false</span>
        })
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package bstore

import (
        "fmt"
        "math"
        "reflect"
        "strconv"
        "time"

        bolt "github.com/etcd-io/bbolt"
)

// Types returns the types present in the database, regardless of whether they
// are currently registered using Open or Register. Useful for exporting data
// with Keys and Records.
func (db *DB) Types() ([]string, error) <span class="cov8" title="1">{
        var types []string
        err := db.Read(func(tx *Tx) error </span><span class="cov8" title="1">{
                return tx.btx.ForEach(func(bname []byte, b *bolt.Bucket) error </span><span class="cov8" title="1">{
                        // note: we do not track stats for types operations.

                        types = append(types, string(bname))
                        return nil
                }</span>)
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return types, nil</span>
}

// prepareType prepares typeName for export/introspection with DB.Keys,
// DB.Record, DB.Records. It is different in that it does not require a
// reflect.Type to parse into. It parses to a map, e.g. for export to JSON. The
// returned typeVersion has no structFields set in its fields.
func (db *DB) prepareType(tx *Tx, typeName string) (map[uint32]*typeVersion, *typeVersion, *bolt.Bucket, []string, error) <span class="cov8" title="1">{
        rb, err := tx.recordsBucket(typeName, 0.5)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, nil, err
        }</span>
        <span class="cov8" title="1">tb, err := tx.bucket(bucketKey{typeName, "types"})
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, nil, err
        }</span>
        <span class="cov8" title="1">versions := map[uint32]*typeVersion{}
        var tv *typeVersion
        err = tb.ForEach(func(bk, bv []byte) error </span><span class="cov8" title="1">{
                // note: we do not track stats for types operations.

                ntv, err := parseSchema(bk, bv)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">versions[ntv.Version] = ntv
                if tv == nil || ntv.Version &gt; tv.Version </span><span class="cov8" title="1">{
                        tv = ntv
                }</span>

                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, nil, nil, nil, err
        }</span>
        <span class="cov8" title="1">if tv == nil </span><span class="cov0" title="0">{
                return nil, nil, nil, nil, fmt.Errorf("%w: no type versions", ErrStore)
        }</span>
        <span class="cov8" title="1">fields := make([]string, len(tv.Fields))
        for i, f := range tv.Fields </span><span class="cov8" title="1">{
                fields[i] = f.Name
        }</span>
        <span class="cov8" title="1">return versions, tv, rb, fields, nil</span>
}

// Keys returns the parsed primary keys for the type "typeName". The type does
// not have to be registered with Open or Register. For use with Record(s) to
// export data.
func (db *DB) Keys(typeName string, fn func(pk any) error) error <span class="cov8" title="1">{
        return db.Read(func(tx *Tx) error </span><span class="cov8" title="1">{
                _, tv, rb, _, err := db.prepareType(tx, typeName)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // todo: do not pass nil parser?
                <span class="cov8" title="1">v := reflect.New(reflect.TypeOf(tv.Fields[0].Type.zero(nil))).Elem()
                return rb.ForEach(func(bk, bv []byte) error </span><span class="cov8" title="1">{
                        tx.stats.Records.Cursor++

                        if err := parsePK(v, bk); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">return fn(v.Interface())</span>
                })
        })
}

// Record returns the record with primary "key" for "typeName" parsed as map.
// "Fields" is set to the fields of the type. The type does not have to be
// registered with Open or Register.  Record parses the data without the Go
// type present. BinaryMarshal fields are returned as bytes.
func (db *DB) Record(typeName, key string, fields *[]string) (map[string]any, error) <span class="cov8" title="1">{
        var r map[string]any
        err := db.Read(func(tx *Tx) error </span><span class="cov8" title="1">{
                versions, tv, rb, xfields, err := db.prepareType(tx, typeName)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">*fields = xfields

                var kv any
                switch tv.Fields[0].Type.Kind </span>{
                case kindBool:<span class="cov8" title="1">
                        switch key </span>{
                        case "true":<span class="cov8" title="1">
                                kv = true</span>
                        case "false":<span class="cov0" title="0">
                                kv = false</span>
                        default:<span class="cov0" title="0">
                                err = fmt.Errorf("%w: invalid bool %q", ErrParam, key)</span>
                        }
                case kindInt8:<span class="cov8" title="1">
                        kv, err = strconv.ParseInt(key, 10, 8)</span>
                case kindInt16:<span class="cov8" title="1">
                        kv, err = strconv.ParseInt(key, 10, 16)</span>
                case kindInt32:<span class="cov8" title="1">
                        kv, err = strconv.ParseInt(key, 10, 32)</span>
                case kindInt:<span class="cov8" title="1">
                        kv, err = strconv.ParseInt(key, 10, 32)</span>
                case kindInt64:<span class="cov8" title="1">
                        kv, err = strconv.ParseInt(key, 10, 64)</span>
                case kindUint8:<span class="cov8" title="1">
                        kv, err = strconv.ParseUint(key, 10, 8)</span>
                case kindUint16:<span class="cov8" title="1">
                        kv, err = strconv.ParseUint(key, 10, 16)</span>
                case kindUint32:<span class="cov8" title="1">
                        kv, err = strconv.ParseUint(key, 10, 32)</span>
                case kindUint:<span class="cov8" title="1">
                        kv, err = strconv.ParseUint(key, 10, 32)</span>
                case kindUint64:<span class="cov8" title="1">
                        kv, err = strconv.ParseUint(key, 10, 64)</span>
                case kindString:<span class="cov8" title="1">
                        kv = key</span>
                case kindBytes:<span class="cov8" title="1">
                        kv = []byte(key)</span> // todo: or decode from base64?
                default:<span class="cov0" title="0">
                        return fmt.Errorf("internal error: unknown primary key kind %v", tv.Fields[0].Type.Kind)</span>
                }
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">pkv := reflect.ValueOf(kv)
                kind, err := typeKind(pkv.Type())
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if kind != tv.Fields[0].Type.Kind </span><span class="cov8" title="1">{
                        // Convert from various int types above to required type. The ParseInt/ParseUint
                        // calls already validated that the values fit.
                        pkt := reflect.TypeOf(tv.Fields[0].Type.zero(nil))
                        pkv = pkv.Convert(pkt)
                }</span>
                <span class="cov8" title="1">k, err := packPK(pkv)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">tx.stats.Records.Get++
                bv := rb.Get(k)
                if bv == nil </span><span class="cov0" title="0">{
                        return ErrAbsent
                }</span>
                <span class="cov8" title="1">record, err := parseMap(versions, k, bv)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">r = record
                return nil</span>
        })
        <span class="cov8" title="1">return r, err</span>
}

// Records calls "fn" for each record of "typeName". Records sets "fields" to
// the fields of the type. The type does not have to be registered with Open or
// Register.  Record parses the data without the Go type present. BinaryMarshal
// fields are returned as bytes.
func (db *DB) Records(typeName string, fields *[]string, fn func(map[string]any) error) error <span class="cov8" title="1">{
        return db.Read(func(tx *Tx) error </span><span class="cov8" title="1">{
                versions, _, rb, xfields, err := db.prepareType(tx, typeName)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">*fields = xfields

                return rb.ForEach(func(bk, bv []byte) error </span><span class="cov8" title="1">{
                        tx.stats.Records.Cursor++

                        record, err := parseMap(versions, bk, bv)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">return fn(record)</span>
                })
        })
}

// parseMap parses a record into a map with the right typeVersion from versions.
func parseMap(versions map[uint32]*typeVersion, bk, bv []byte) (record map[string]any, rerr error) <span class="cov8" title="1">{
        p := &amp;parser{buf: bv, orig: bv}
        var version uint32

        defer func() </span><span class="cov8" title="1">{
                x := recover()
                if x == nil </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov0" title="0">if err, ok := x.(parseErr); ok </span><span class="cov0" title="0">{
                        rerr = fmt.Errorf("%w (version %d, buf %x orig %x)", err.err, version, p.buf, p.orig)
                        return
                }</span>
                <span class="cov0" title="0">panic(x)</span>
        }()

        <span class="cov8" title="1">version = uint32(p.Uvarint())
        tv := versions[version]
        if tv == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%w: unknown type version %d", ErrStore, version)
        }</span>

        <span class="cov8" title="1">r := map[string]any{}

        v := reflect.New(reflect.TypeOf(tv.Fields[0].Type.zero(p))).Elem()
        err := parsePK(v, bk)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">r[tv.Fields[0].Name] = v.Interface()

        // todo: Should we be looking at the most recent tv, and hiding fields
        // that have been removed in a later typeVersion? Like we do for real
        // parsing into reflect value?
        fm := p.Fieldmap(len(tv.Fields) - 1)
        for i, f := range tv.Fields[1:] </span><span class="cov8" title="1">{
                if fm.Nonzero(i) </span><span class="cov8" title="1">{
                        r[f.Name] = f.Type.parseValue(p)
                }</span> else<span class="cov8" title="1"> {
                        r[f.Name] = f.Type.zero(p)
                }</span>
        }

        <span class="cov8" title="1">if len(p.buf) != 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%w: leftover data after parsing", ErrStore)
        }</span>

        <span class="cov8" title="1">return r, nil</span>
}

func (ft fieldType) parseValue(p *parser) any <span class="cov8" title="1">{
        switch ft.Kind </span>{
        case kindBytes:<span class="cov8" title="1">
                return p.TakeBytes(false)</span>
        case kindBinaryMarshal:<span class="cov8" title="1">
                // We don't have the type available, so we just return the binary data.
                return p.TakeBytes(false)</span>
        case kindBool:<span class="cov8" title="1">
                return true</span>
        case kindInt8:<span class="cov8" title="1">
                return int8(p.Varint())</span>
        case kindInt16:<span class="cov8" title="1">
                return int16(p.Varint())</span>
        case kindInt32:<span class="cov8" title="1">
                return int32(p.Varint())</span>
        case kindInt:<span class="cov8" title="1">
                i := p.Varint()
                if i &lt; math.MinInt32 || i &gt; math.MaxInt32 </span><span class="cov0" title="0">{
                        p.Errorf("%w: int %d does not fit in int32", ErrStore, i)
                }</span>
                <span class="cov8" title="1">return int(i)</span>
        case kindInt64:<span class="cov8" title="1">
                return p.Varint()</span>
        case kindUint8:<span class="cov8" title="1">
                return uint8(p.Uvarint())</span>
        case kindUint16:<span class="cov8" title="1">
                return uint16(p.Uvarint())</span>
        case kindUint32:<span class="cov8" title="1">
                return uint32(p.Uvarint())</span>
        case kindUint:<span class="cov8" title="1">
                i := p.Uvarint()
                if i &gt; math.MaxUint32 </span><span class="cov0" title="0">{
                        p.Errorf("%w: uint %d does not fit in uint32", ErrStore, i)
                }</span>
                <span class="cov8" title="1">return uint(i)</span>
        case kindUint64:<span class="cov8" title="1">
                return p.Uvarint()</span>
        case kindFloat32:<span class="cov8" title="1">
                return math.Float32frombits(uint32(p.Uvarint()))</span>
        case kindFloat64:<span class="cov8" title="1">
                return math.Float64frombits(p.Uvarint())</span>
        case kindString:<span class="cov8" title="1">
                return string(p.TakeBytes(false))</span>
        case kindTime:<span class="cov8" title="1">
                var t time.Time
                err := t.UnmarshalBinary(p.TakeBytes(false))
                if err != nil </span><span class="cov0" title="0">{
                        p.Errorf("%w: parsing time: %v", ErrStore, err)
                }</span>
                <span class="cov8" title="1">return t</span>
        case kindSlice:<span class="cov8" title="1">
                un := p.Uvarint()
                n := p.checkInt(un)
                fm := p.Fieldmap(n)
                var l []any
                for i := 0; i &lt; n; i++ </span><span class="cov8" title="1">{
                        if fm.Nonzero(i) </span><span class="cov8" title="1">{
                                l = append(l, ft.List.parseValue(p))
                        }</span> else<span class="cov8" title="1"> {
                                // Always add non-zero elements, or we would
                                // change the number of elements in a list.
                                l = append(l, ft.List.zero(p))
                        }</span>
                }
                <span class="cov8" title="1">return l</span>
        case kindMap:<span class="cov8" title="1">
                un := p.Uvarint()
                n := p.checkInt(un)
                fm := p.Fieldmap(n)
                m := map[string]any{}
                for i := 0; i &lt; n; i++ </span><span class="cov8" title="1">{
                        // Converting to string can be ugly, but the best we can do.
                        k := fmt.Sprintf("%v", ft.MapKey.parseValue(p))
                        if _, ok := m[k]; ok </span><span class="cov0" title="0">{
                                return fmt.Errorf("%w: duplicate key %q in map", ErrStore, k)
                        }</span>
                        <span class="cov8" title="1">var v any
                        if fm.Nonzero(i) </span><span class="cov8" title="1">{
                                v = ft.MapValue.parseValue(p)
                        }</span> else<span class="cov8" title="1"> {
                                v = ft.MapValue.zero(p)
                        }</span>
                        <span class="cov8" title="1">m[k] = v</span>
                }
                <span class="cov8" title="1">return m</span>
        case kindStruct:<span class="cov8" title="1">
                fm := p.Fieldmap(len(ft.Fields))
                m := map[string]any{}
                for i, f := range ft.Fields </span><span class="cov8" title="1">{
                        if fm.Nonzero(i) </span><span class="cov8" title="1">{
                                m[f.Name] = f.Type.parseValue(p)
                        }</span> else<span class="cov0" title="0"> {
                                m[f.Name] = f.Type.zero(p)
                        }</span>
                }
                <span class="cov8" title="1">return m</span>
        }
        <span class="cov0" title="0">p.Errorf("internal error: unhandled field type %v", ft.Kind)
        panic("cannot happen")</span>
}

var zerovalues = map[kind]any{
        kindBytes:         []byte(nil),
        kindBinaryMarshal: []byte(nil), // We don't have the actual type available, so we just return binary data.
        kindBool:          false,
        kindInt8:          int8(0),
        kindInt16:         int16(0),
        kindInt32:         int32(0),
        kindInt:           int(0),
        kindInt64:         int64(0),
        kindUint8:         uint8(0),
        kindUint16:        uint16(0),
        kindUint32:        uint32(0),
        kindUint:          uint(0),
        kindUint64:        uint64(0),
        kindFloat32:       float32(0),
        kindFloat64:       float64(0),
        kindString:        "",
        kindTime:          zerotime,
        kindSlice:         []any(nil),
        kindMap:           map[string]any(nil),
        kindStruct:        map[string]any(nil),
}

func (ft fieldType) zero(p *parser) any <span class="cov8" title="1">{
        v, ok := zerovalues[ft.Kind]
        if !ok </span><span class="cov0" title="0">{
                p.Errorf("internal error: unhandled zero value for field type %v", ft.Kind)
        }</span>
        <span class="cov8" title="1">return v</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package bstore

import (
        "encoding/binary"
        "fmt"
        "math"
        "reflect"
        "time"
)

/*
The records buckets map a primary key to the record data. The primary key is of
a form that we can scan/range over. So fixed with for integers. For strings and
bytes they are just their byte representation. We do not store the PK in the
record data. This means we cannot store a time.Time as primary key, because we
cannot have the timezone encoded for comparison reasons.

Index keys are similar to PK's. Unique and non-unique indices are encoded the
same. The stored values are always empty, the key consists of the field values
the index was created for, followed by the PK. The encoding of a field is nearly
the same as the encoding of that type as a primary key. The differences: strings
end with a \0 to make them self-delimiting; byte slices are not allowed because
they are not self-delimiting; time.Time is allowed because the time is available
in full (with timezone) in the record data.
*/

// packPK returns the PK bytes representation for the PK value rv.
func packPK(rv reflect.Value) ([]byte, error) <span class="cov8" title="1">{
        kv := rv.Interface()
        var buf []byte
        switch k := kv.(type) </span>{
        case string:<span class="cov8" title="1">
                buf = []byte(k)</span>
        case []byte:<span class="cov8" title="1">
                buf = k</span>
        case bool:<span class="cov8" title="1">
                var b byte
                if k </span><span class="cov8" title="1">{
                        b = 1
                }</span>
                <span class="cov8" title="1">buf = []byte{b}</span>
        case int8:<span class="cov8" title="1">
                buf = []byte{byte(uint8(k + math.MinInt8))}</span>
        case int16:<span class="cov8" title="1">
                buf = binary.BigEndian.AppendUint16(nil, uint16(k+math.MinInt16))</span>
        case int32:<span class="cov8" title="1">
                buf = binary.BigEndian.AppendUint32(nil, uint32(k+math.MinInt32))</span>
        case int:<span class="cov8" title="1">
                if k &lt; math.MinInt32 || k &gt; math.MaxInt32 </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("%w: int %d does not fit in int32", ErrParam, k)
                }</span>
                <span class="cov8" title="1">buf = binary.BigEndian.AppendUint32(nil, uint32(k+math.MinInt32))</span>
        case int64:<span class="cov8" title="1">
                buf = binary.BigEndian.AppendUint64(nil, uint64(k+math.MinInt64))</span>
        case uint8:<span class="cov8" title="1">
                buf = []byte{k}</span>
        case uint16:<span class="cov8" title="1">
                buf = binary.BigEndian.AppendUint16(nil, k)</span>
        case uint32:<span class="cov8" title="1">
                buf = binary.BigEndian.AppendUint32(nil, k)</span>
        case uint:<span class="cov8" title="1">
                if k &gt; math.MaxUint32 </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("%w: uint %d does not fit in uint32", ErrParam, k)
                }</span>
                <span class="cov8" title="1">buf = binary.BigEndian.AppendUint32(nil, uint32(k))</span>
        case uint64:<span class="cov8" title="1">
                buf = binary.BigEndian.AppendUint64(nil, k)</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("%w: unsupported primary key type %T", ErrType, kv)</span>
        }
        <span class="cov8" title="1">return buf, nil</span>
}

// parsePK parses primary key bk into rv.
func parsePK(rv reflect.Value, bk []byte) error <span class="cov8" title="1">{
        k, err := typeKind(rv.Type())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">switch k </span>{
        case kindBytes:<span class="cov8" title="1">
                buf := make([]byte, len(bk))
                copy(buf, bk)
                rv.SetBytes(buf)
                return nil</span>
        case kindString:<span class="cov8" title="1">
                rv.SetString(string(bk))
                return nil</span>
        }

        <span class="cov8" title="1">var need int
        switch k </span>{
        case kindBool, kindInt8, kindUint8:<span class="cov8" title="1">
                need = 1</span>
        case kindInt16, kindUint16:<span class="cov8" title="1">
                need = 2</span>
        case kindInt32, kindUint32, kindInt, kindUint:<span class="cov8" title="1">
                need = 4</span>
        case kindInt64, kindUint64:<span class="cov8" title="1">
                need = 8</span>
        }
        <span class="cov8" title="1">if len(bk) != need </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: got %d bytes for PK, need %d", ErrStore, len(bk), need)
        }</span>

        <span class="cov8" title="1">switch k </span>{
        case kindBool:<span class="cov8" title="1">
                rv.SetBool(bk[0] != 0)</span>
        case kindInt8:<span class="cov8" title="1">
                rv.SetInt(int64(int8(bk[0]) - math.MinInt8))</span>
        case kindInt16:<span class="cov8" title="1">
                rv.SetInt(int64(int16(binary.BigEndian.Uint16(bk)) - math.MinInt16))</span>
        case kindInt32, kindInt:<span class="cov8" title="1">
                rv.SetInt(int64(int32(binary.BigEndian.Uint32(bk)) - math.MinInt32))</span>
        case kindInt64:<span class="cov8" title="1">
                rv.SetInt(int64(int64(binary.BigEndian.Uint64(bk)) - math.MinInt64))</span>
        case kindUint8:<span class="cov8" title="1">
                rv.SetUint(uint64(bk[0]))</span>
        case kindUint16:<span class="cov8" title="1">
                rv.SetUint(uint64(binary.BigEndian.Uint16(bk)))</span>
        case kindUint32, kindUint:<span class="cov8" title="1">
                rv.SetUint(uint64(binary.BigEndian.Uint32(bk)))</span>
        case kindUint64:<span class="cov8" title="1">
                rv.SetUint(uint64(binary.BigEndian.Uint64(bk)))</span>
        default:<span class="cov0" title="0">
                // note: we cannot have kindTime as primary key at the moment.
                return fmt.Errorf("%w: unsupported primary key type %v", ErrType, rv.Type())</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// parseKey parses the PK (last element) of an index key.
// If all is set, also gathers the values before and returns them in the second
// parameter.
func (idx *index) parseKey(buf []byte, all bool) ([]byte, [][]byte, error) <span class="cov8" title="1">{
        var err error
        var keys [][]byte
        take := func(n int) </span><span class="cov8" title="1">{
                if len(buf) &lt; n </span><span class="cov0" title="0">{
                        err = fmt.Errorf("%w: not enough bytes in index key", ErrStore)
                        return
                }</span>
                <span class="cov8" title="1">if all </span><span class="cov8" title="1">{
                        keys = append(keys, buf[:n])
                }</span>
                <span class="cov8" title="1">buf = buf[n:]</span>
        }
<span class="cov8" title="1">fields:
        for _, f := range idx.Fields </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov8" title="1">switch f.Type.Kind </span>{
                case kindString:<span class="cov8" title="1">
                        for i, b := range buf </span><span class="cov8" title="1">{
                                if b == 0 </span><span class="cov8" title="1">{
                                        if all </span><span class="cov8" title="1">{
                                                keys = append(keys, buf[:i])
                                        }</span>
                                        <span class="cov8" title="1">buf = buf[i+1:]
                                        continue fields</span>
                                }
                        }
                        <span class="cov0" title="0">err = fmt.Errorf("%w: bad string without 0 in index key", ErrStore)</span>
                case kindBool:<span class="cov8" title="1">
                        take(1)</span>
                case kindInt8, kindUint8:<span class="cov8" title="1">
                        take(1)</span>
                case kindInt16, kindUint16:<span class="cov8" title="1">
                        take(2)</span>
                case kindInt32, kindUint32, kindInt, kindUint:<span class="cov8" title="1">
                        take(4)</span>
                case kindInt64, kindUint64:<span class="cov8" title="1">
                        take(8)</span>
                case kindTime:<span class="cov8" title="1">
                        take(8 + 4)</span>
                }
        }
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">pk := buf

        switch idx.tv.Fields[0].Type.Kind </span>{
        case kindBool:<span class="cov0" title="0">
                take(1)</span>
        case kindInt8, kindUint8:<span class="cov0" title="0">
                take(1)</span>
        case kindInt16, kindUint16:<span class="cov0" title="0">
                take(2)</span>
        case kindInt32, kindInt, kindUint32, kindUint:<span class="cov8" title="1">
                take(4)</span>
        case kindInt64, kindUint64:<span class="cov8" title="1">
                take(8)</span>
        }
        <span class="cov8" title="1">if len(pk) != len(buf) &amp;&amp; len(buf) != 0 </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("%w: leftover bytes in index key (%x)", ErrStore, buf)
        }</span>
        <span class="cov8" title="1">if all </span><span class="cov8" title="1">{
                return pk, keys[:len(keys)-1], nil
        }</span>
        <span class="cov8" title="1">return pk, nil, nil</span>
}

// packKey returns a key to store in an index: first the prefix without pk, then
// the prefix including pk.
func (idx *index) packKey(rv reflect.Value, pk []byte) ([]byte, []byte, error) <span class="cov8" title="1">{
        var l []reflect.Value
        for _, f := range idx.Fields </span><span class="cov8" title="1">{
                frv := rv.FieldByIndex(f.structField.Index)
                l = append(l, frv)
        }</span>
        <span class="cov8" title="1">return packIndexKeys(l, pk)</span>
}

// packIndexKeys packs values from l, followed by the pk.
// It returns the key prefix (without pk), and full key with pk.
func packIndexKeys(l []reflect.Value, pk []byte) ([]byte, []byte, error) <span class="cov8" title="1">{
        var prek, ik []byte
        for _, frv := range l </span><span class="cov8" title="1">{
                k, err := typeKind(frv.Type())
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>
                <span class="cov8" title="1">var buf []byte
                switch k </span>{
                case kindBool:<span class="cov8" title="1">
                        buf = []byte{0}
                        if frv.Bool() </span><span class="cov8" title="1">{
                                buf[0] = 1
                        }</span>
                case kindInt8:<span class="cov8" title="1">
                        buf = []byte{byte(int8(frv.Int()) + math.MinInt8)}</span>
                case kindInt16:<span class="cov8" title="1">
                        buf = binary.BigEndian.AppendUint16(nil, uint16(int16(frv.Int())+math.MinInt16))</span>
                case kindInt32:<span class="cov8" title="1">
                        buf = binary.BigEndian.AppendUint32(nil, uint32(int32(frv.Int())+math.MinInt32))</span>
                case kindInt:<span class="cov8" title="1">
                        i := frv.Int()
                        if i &lt; math.MinInt32 || i &gt; math.MaxInt32 </span><span class="cov0" title="0">{
                                return nil, nil, fmt.Errorf("%w: int value %d does not fit in int32", ErrParam, i)
                        }</span>
                        <span class="cov8" title="1">buf = binary.BigEndian.AppendUint32(nil, uint32(int32(i)+math.MinInt32))</span>
                case kindInt64:<span class="cov8" title="1">
                        buf = binary.BigEndian.AppendUint64(nil, uint64(frv.Int()+math.MinInt64))</span>
                case kindUint8:<span class="cov8" title="1">
                        buf = []byte{byte(frv.Uint())}</span>
                case kindUint16:<span class="cov8" title="1">
                        buf = binary.BigEndian.AppendUint16(nil, uint16(frv.Uint()))</span>
                case kindUint32:<span class="cov8" title="1">
                        buf = binary.BigEndian.AppendUint32(nil, uint32(frv.Uint()))</span>
                case kindUint:<span class="cov8" title="1">
                        i := frv.Uint()
                        if i &gt; math.MaxUint32 </span><span class="cov0" title="0">{
                                return nil, nil, fmt.Errorf("%w: uint value %d does not fit in uint32", ErrParam, i)
                        }</span>
                        <span class="cov8" title="1">buf = binary.BigEndian.AppendUint32(nil, uint32(i))</span>
                case kindUint64:<span class="cov8" title="1">
                        buf = binary.BigEndian.AppendUint64(nil, uint64(frv.Uint()))</span>
                case kindString:<span class="cov8" title="1">
                        buf = []byte(frv.String())
                        for _, c := range buf </span><span class="cov8" title="1">{
                                if c == 0 </span><span class="cov8" title="1">{
                                        return nil, nil, fmt.Errorf("%w: string used as index key cannot have \\0", ErrParam)
                                }</span>
                        }
                        <span class="cov8" title="1">buf = append(buf, 0)</span>
                case kindTime:<span class="cov8" title="1">
                        tm := frv.Interface().(time.Time)
                        buf = binary.BigEndian.AppendUint64(nil, uint64(tm.Unix()+math.MinInt64))
                        buf = binary.BigEndian.AppendUint32(buf, uint32(tm.Nanosecond()))</span>
                default:<span class="cov0" title="0">
                        return nil, nil, fmt.Errorf("internal error: bad type %v for index", frv.Type())</span> // todo: should be caught when making index type
                }
                <span class="cov8" title="1">ik = append(ik, buf...)</span>
        }
        <span class="cov8" title="1">n := len(ik)
        ik = append(ik, pk...)
        prek = ik[:n]
        return prek, ik, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package bstore

import (
        "fmt"
        "reflect"
)

// isZero returns whether v is the zero value for the fields that we store.
// reflect.IsZero cannot be used on structs because it checks private fields as well.
func (ft fieldType) isZero(v reflect.Value) bool <span class="cov8" title="1">{
        if !v.IsValid() </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">if ft.Ptr </span><span class="cov8" title="1">{
                return v.IsNil()
        }</span>
        <span class="cov8" title="1">switch ft.Kind </span>{
        case kindStruct:<span class="cov8" title="1">
                for _, f := range ft.Fields </span><span class="cov8" title="1">{
                        if !f.Type.isZero(v.FieldByIndex(f.structField.Index)) </span><span class="cov8" title="1">{
                                return false
                        }</span>
                }
                <span class="cov8" title="1">return true</span>
        }
        // Use standard IsZero otherwise, also for kindBinaryMarshal.
        <span class="cov8" title="1">return v.IsZero()</span>
}

// checkNonzero compare ofields and nfields (from previous type schema vs newly
// created type schema) for nonzero struct tag. If an existing field got a
// nonzero struct tag added, we verify that there are indeed no nonzero values
// in the database. If there are, we return ErrZero.
func (tx *Tx) checkNonzero(st storeType, tv *typeVersion, ofields, nfields []field) error <span class="cov8" title="1">{
        // First we gather paths that we need to check, so we can later simply
        // execute those steps on all data we need to read.
        paths := &amp;follows{}
next:
        for _, f := range nfields </span><span class="cov8" title="1">{
                for _, of := range ofields </span><span class="cov8" title="1">{
                        if f.Name == of.Name </span><span class="cov8" title="1">{
                                err := f.checkNonzeroGather(&amp;of, paths)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov8" title="1">continue next</span>
                        }
                }
                <span class="cov8" title="1">if err := f.checkNonzeroGather(nil, paths); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">if len(paths.paths) == 0 </span><span class="cov8" title="1">{
                // Common case, not reading all data.
                return nil
        }</span>

        // Finally actually do the checks.
        // todo: if there are only top-level fields to check, and we have an index, we can use the index check this without reading all data.
        <span class="cov8" title="1">return tx.checkNonzeroPaths(st, tv, paths.paths)</span>
}

type follow struct {
        mapKey, mapValue bool
        field            field
}

type follows struct {
        current []follow
        paths   [][]follow
}

func (f *follows) push(ff follow) <span class="cov8" title="1">{
        f.current = append(f.current, ff)
}</span>

func (f *follows) pop() <span class="cov8" title="1">{
        f.current = f.current[:len(f.current)-1]
}</span>

func (f *follows) add() <span class="cov8" title="1">{
        f.paths = append(f.paths, append([]follow{}, f.current...))
}</span>

func (f field) checkNonzeroGather(of *field, paths *follows) error <span class="cov8" title="1">{
        paths.push(follow{field: f})
        defer paths.pop()
        if f.Nonzero &amp;&amp; (of == nil || !of.Nonzero) </span><span class="cov8" title="1">{
                paths.add()
        }</span>
        <span class="cov8" title="1">if of != nil </span><span class="cov8" title="1">{
                return f.Type.checkNonzeroGather(of.Type, paths)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (ft fieldType) checkNonzeroGather(oft fieldType, paths *follows) error <span class="cov8" title="1">{
        switch ft.Kind </span>{
        case kindMap:<span class="cov8" title="1">
                paths.push(follow{mapKey: true})
                if err := ft.MapKey.checkNonzeroGather(*oft.MapKey, paths); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">paths.pop()

                paths.push(follow{mapValue: true})
                if err := ft.MapValue.checkNonzeroGather(*oft.MapValue, paths); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">paths.pop()</span>

        case kindSlice:<span class="cov8" title="1">
                err := ft.List.checkNonzeroGather(*oft.List, paths)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case kindStruct:<span class="cov8" title="1">
        next:
                for _, ff := range ft.Fields </span><span class="cov8" title="1">{
                        for _, off := range oft.Fields </span><span class="cov8" title="1">{
                                if ff.Name == off.Name </span><span class="cov8" title="1">{
                                        err := ff.checkNonzeroGather(&amp;off, paths)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                        <span class="cov8" title="1">continue next</span>
                                }
                        }
                        <span class="cov0" title="0">err := ff.checkNonzeroGather(nil, paths)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

        }
        <span class="cov8" title="1">return nil</span>
}

// checkNonzero reads through all records of a type, and checks that the fields
// indicated by paths are nonzero. If not, ErrZero is returned.
func (tx *Tx) checkNonzeroPaths(st storeType, tv *typeVersion, paths [][]follow) error <span class="cov8" title="1">{
        rb, err := tx.recordsBucket(st.Current.name, st.Current.fillPercent)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return rb.ForEach(func(bk, bv []byte) error </span><span class="cov8" title="1">{
                tx.stats.Records.Cursor++

                rv, err := st.parseNew(bk, bv)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                // todo optimization: instead of parsing the full record, use the fieldmap to see if the value is nonzero.
                <span class="cov8" title="1">for _, path := range paths </span><span class="cov8" title="1">{
                        frv := rv.FieldByIndex(path[0].field.structField.Index)
                        if err := path[0].field.checkNonzero(frv, path[1:]); err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                }
                <span class="cov8" title="1">return nil</span>
        })
}

func (f field) checkNonzero(rv reflect.Value, path []follow) error <span class="cov8" title="1">{
        if len(path) == 0 </span><span class="cov8" title="1">{
                if !f.Nonzero </span><span class="cov0" title="0">{
                        return fmt.Errorf("internal error: checkNonzero: expected field to have Nonzero set")
                }</span>
                <span class="cov8" title="1">if f.Type.isZero(rv) </span><span class="cov8" title="1">{
                        return fmt.Errorf("%w: field %q", ErrZero, f.Name)
                }</span>
                <span class="cov8" title="1">return nil</span>
        }
        <span class="cov8" title="1">return f.Type.checkNonzero(rv, path)</span>
}

func (ft fieldType) checkNonzero(rv reflect.Value, path []follow) error <span class="cov8" title="1">{
        switch ft.Kind </span>{
        case kindMap:<span class="cov8" title="1">
                follow := path[0]
                path = path[1:]
                key := follow.mapKey
                if !key &amp;&amp; !follow.mapValue </span><span class="cov0" title="0">{
                        return fmt.Errorf("internal error: following map, expected mapKey or mapValue, got %#v", follow)
                }</span>

                <span class="cov8" title="1">iter := rv.MapRange()
                for iter.Next() </span><span class="cov8" title="1">{
                        var err error
                        if key </span><span class="cov8" title="1">{
                                err = ft.MapKey.checkNonzero(iter.Key(), path)
                        }</span> else<span class="cov8" title="1"> {
                                err = ft.MapValue.checkNonzero(iter.Value(), path)
                        }</span>
                        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                }
        case kindSlice:<span class="cov8" title="1">
                n := rv.Len()
                for i := 0; i &lt; n; i++ </span><span class="cov8" title="1">{
                        if err := ft.List.checkNonzero(rv.Index(i), path); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        case kindStruct:<span class="cov8" title="1">
                follow := path[0]
                path = path[1:]
                frv := rv.FieldByIndex(follow.field.structField.Index)
                if err := follow.field.checkNonzero(frv, path); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("internal error: checkNonzero with non-empty path, but kind %v", ft.Kind)</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package bstore

import (
        "bytes"
        "encoding"
        "encoding/binary"
        "fmt"
        "math"
        "reflect"
        "time"
)

// fieldmap represents a bitmap indicating which fields are actually stored and
// can be parsed. zero values for fields are not otherwise stored.
type fieldmap struct {
        max    int    // Required number of fields.
        buf    []byte // Bitmap, we write the next 0/1 at bit n.
        n      int    // Fields seen so far.
        offset int    // In final output, we write buf back after finish. Only relevant for packing.
        Errorf func(format string, args ...any)
}

// add bit to fieldmap indicating if the field is nonzero.
func (f *fieldmap) Field(nonzero bool) <span class="cov8" title="1">{
        o := f.n / 8
        if f.n &gt;= f.max </span><span class="cov0" title="0">{
                f.Errorf("internal error: too many fields, max %d", f.max)
        }</span>
        <span class="cov8" title="1">if nonzero </span><span class="cov8" title="1">{
                f.buf[o] |= 1 &lt;&lt; (7 - f.n%8)
        }</span>
        <span class="cov8" title="1">f.n++</span>
}

// check if field i is nonzero.
func (f *fieldmap) Nonzero(i int) bool <span class="cov8" title="1">{
        v := f.buf[i/8]&amp;(1&lt;&lt;(7-i%8)) != 0
        return v
}</span>

type packer struct {
        b         *bytes.Buffer
        offset    int
        fieldmaps []*fieldmap // Pending fieldmaps, not excluding fieldmap below.
        fieldmap  *fieldmap   // Currently active.
        popped    []*fieldmap // Completed fieldmaps, to be written back during finish.
}

func (p *packer) Errorf(format string, args ...any) <span class="cov8" title="1">{
        panic(packErr{fmt.Errorf(format, args...)})</span>
}

// Push a new fieldmap on the stack for n fields.
func (p *packer) PushFieldmap(n int) <span class="cov8" title="1">{
        p.fieldmaps = append(p.fieldmaps, p.fieldmap)
        buf := make([]byte, (n+7)/8)
        p.fieldmap = &amp;fieldmap{max: n, buf: buf, offset: p.offset, Errorf: p.Errorf}
        p.Write(buf) // Updates offset. Write errors cause panic.
}</span>

// Pop a fieldmap from the stack. It is remembered in popped for writing the
// bytes during finish.
func (p *packer) PopFieldmap() <span class="cov8" title="1">{
        if p.fieldmap.n != p.fieldmap.max </span><span class="cov0" title="0">{
                p.Errorf("internal error: fieldmap n %d != max %d", p.fieldmap.n, p.fieldmap.max)
        }</span>
        <span class="cov8" title="1">p.popped = append(p.popped, p.fieldmap)
        p.fieldmap = p.fieldmaps[len(p.fieldmaps)-1]
        p.fieldmaps = p.fieldmaps[:len(p.fieldmaps)-1]</span>
}

// Finish writes back finished (popped) fieldmaps to the correct offset,
// returning the final bytes representation of this record.
func (p *packer) Finish() []byte <span class="cov8" title="1">{
        if p.fieldmap != nil </span><span class="cov0" title="0">{
                p.Errorf("internal error: leftover fieldmap during finish")
        }</span>
        <span class="cov8" title="1">buf := p.b.Bytes()
        for _, f := range p.popped </span><span class="cov8" title="1">{
                copy(buf[f.offset:], f.buf)
        }</span>
        <span class="cov8" title="1">return buf</span>
}

// Field adds field with nonzeroness to the current fieldmap.
func (p *packer) Field(nonzero bool) <span class="cov8" title="1">{
        p.fieldmap.Field(nonzero)
}</span>

func (p *packer) Write(buf []byte) (int, error) <span class="cov8" title="1">{
        n, err := p.b.Write(buf)
        if err != nil </span><span class="cov0" title="0">{
                p.Errorf("write: %w", err)
        }</span>
        <span class="cov8" title="1">if n &gt; 0 </span><span class="cov8" title="1">{
                p.offset += n
        }</span>
        <span class="cov8" title="1">return n, err</span>
}

func (p *packer) AddBytes(buf []byte) <span class="cov8" title="1">{
        p.Uvarint(uint64(len(buf)))
        p.Write(buf) // Write errors cause panic.
}</span>

func (p *packer) Uvarint(v uint64) <span class="cov8" title="1">{
        buf := make([]byte, binary.MaxVarintLen64)
        o := binary.PutUvarint(buf, v)
        p.Write(buf[:o]) // Write errors cause panic.
}</span>

func (p *packer) Varint(v int64) <span class="cov8" title="1">{
        buf := make([]byte, binary.MaxVarintLen64)
        o := binary.PutVarint(buf, v)
        p.Write(buf[:o]) // Write errors cause panic.
}</span>

type packErr struct {
        err error
}

// pack rv (reflect.Struct), excluding the primary key field.
func (st storeType) pack(rv reflect.Value) (rbuf []byte, rerr error) <span class="cov8" title="1">{
        p := &amp;packer{b: &amp;bytes.Buffer{}}
        defer func() </span><span class="cov8" title="1">{
                x := recover()
                if x == nil </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">perr, ok := x.(packErr)
                if ok </span><span class="cov8" title="1">{
                        rerr = perr.err
                        return
                }</span>
                <span class="cov0" title="0">panic(x)</span>
        }()
        <span class="cov8" title="1">st.Current.pack(p, rv)
        return p.Finish(), nil</span>
}

func (tv typeVersion) pack(p *packer, rv reflect.Value) <span class="cov8" title="1">{
        // When parsing, the same typeVersion (type schema) is used to
        // interpret the bytes correctly.
        p.Uvarint(uint64(tv.Version))

        p.PushFieldmap(len(tv.Fields) - 1)

        for _, f := range tv.Fields[1:] </span><span class="cov8" title="1">{
                nrv := rv.FieldByIndex(f.structField.Index)
                if f.Type.isZero(nrv) </span><span class="cov8" title="1">{
                        if f.Nonzero </span><span class="cov8" title="1">{
                                p.Errorf("%w: %q", ErrZero, f.Name)
                        }</span>
                        <span class="cov8" title="1">p.Field(false)
                        // Pretend to pack to get the nonzero checks.
                        if nrv.IsValid() &amp;&amp; (nrv.Kind() != reflect.Ptr || !nrv.IsNil()) </span><span class="cov8" title="1">{
                                f.Type.pack(&amp;packer{b: &amp;bytes.Buffer{}}, nrv)
                        }</span>
                } else<span class="cov8" title="1"> {
                        p.Field(true)
                        f.Type.pack(p, nrv)
                }</span>
        }
        <span class="cov8" title="1">p.PopFieldmap()</span>
}

// pack the nonzero value rv.
func (ft fieldType) pack(p *packer, rv reflect.Value) <span class="cov8" title="1">{
        if ft.Ptr </span><span class="cov8" title="1">{
                rv = rv.Elem()
        }</span>
        <span class="cov8" title="1">switch ft.Kind </span>{
        case kindBytes:<span class="cov8" title="1">
                p.AddBytes(rv.Bytes())</span>
        case kindBinaryMarshal:<span class="cov8" title="1">
                v := rv
                buf, err := v.Interface().(encoding.BinaryMarshaler).MarshalBinary()
                if err != nil </span><span class="cov0" title="0">{
                        p.Errorf("marshalbinary: %w", err)
                }</span>
                <span class="cov8" title="1">p.AddBytes(buf)</span>
        case kindBool:<span class="cov8" title="1"></span>
                // No value needed. If false, it would be zero, handled above,
                // with a 0 in the fieldmap.
        case kindInt:<span class="cov8" title="1">
                v := rv.Int()
                if v &lt; math.MinInt32 || v &gt; math.MaxInt32 </span><span class="cov8" title="1">{
                        p.Errorf("%w: int %d does not fit in int32", ErrParam, v)
                }</span>
                <span class="cov8" title="1">p.Varint(v)</span>
        case kindInt8, kindInt16, kindInt32, kindInt64:<span class="cov8" title="1">
                p.Varint(rv.Int())</span>
        case kindUint8, kindUint16, kindUint32, kindUint64:<span class="cov8" title="1">
                p.Uvarint(rv.Uint())</span>
        case kindUint:<span class="cov8" title="1">
                v := rv.Uint()
                if v &gt; math.MaxUint32 </span><span class="cov8" title="1">{
                        p.Errorf("%w: uint %d does not fit in uint32", ErrParam, v)
                }</span>
                <span class="cov8" title="1">p.Uvarint(v)</span>
        case kindFloat32:<span class="cov8" title="1">
                p.Uvarint(uint64(math.Float32bits(rv.Interface().(float32))))</span>
        case kindFloat64:<span class="cov8" title="1">
                p.Uvarint(uint64(math.Float64bits(rv.Interface().(float64))))</span>
        case kindString:<span class="cov8" title="1">
                p.AddBytes([]byte(rv.String()))</span>
        case kindTime:<span class="cov8" title="1">
                buf, err := rv.Interface().(time.Time).MarshalBinary()
                if err != nil </span><span class="cov0" title="0">{
                        p.Errorf("%w: pack time: %s", ErrParam, err)
                }</span>
                <span class="cov8" title="1">p.AddBytes(buf)</span>
        case kindSlice:<span class="cov8" title="1">
                n := rv.Len()
                p.Uvarint(uint64(n))
                p.PushFieldmap(n)
                for i := 0; i &lt; n; i++ </span><span class="cov8" title="1">{
                        nrv := rv.Index(i)
                        if ft.List.isZero(nrv) </span><span class="cov8" title="1">{
                                p.Field(false)
                                // Pretend to pack to get the nonzero checks of the element.
                                if nrv.IsValid() &amp;&amp; (nrv.Kind() != reflect.Ptr || !nrv.IsNil()) </span><span class="cov8" title="1">{
                                        ft.List.pack(&amp;packer{b: &amp;bytes.Buffer{}}, nrv)
                                }</span>
                        } else<span class="cov8" title="1"> {
                                p.Field(true)
                                ft.List.pack(p, nrv)
                        }</span>
                }
                <span class="cov8" title="1">p.PopFieldmap()</span>
        case kindMap:<span class="cov8" title="1">
                // We write a fieldmap for zeroness of the values. The keys are unique, so there
                // can only be max 1 zero key. But there can be many zero values. struct{} is
                // common in Go, good to support that efficiently.
                n := rv.Len()
                p.Uvarint(uint64(n))
                p.PushFieldmap(n)
                iter := rv.MapRange()
                for iter.Next() </span><span class="cov8" title="1">{
                        ft.MapKey.pack(p, iter.Key())
                        v := iter.Value()
                        if ft.MapValue.isZero(v) </span><span class="cov8" title="1">{
                                p.Field(false)
                                // Pretend to pack to get the nonzero checks of the key type.
                                if v.IsValid() &amp;&amp; (v.Kind() != reflect.Ptr || !v.IsNil()) </span><span class="cov8" title="1">{
                                        ft.MapValue.pack(&amp;packer{b: &amp;bytes.Buffer{}}, v)
                                }</span>
                        } else<span class="cov8" title="1"> {
                                p.Field(true)
                                ft.MapValue.pack(p, v)
                        }</span>
                }
                <span class="cov8" title="1">p.PopFieldmap()</span>
        case kindStruct:<span class="cov8" title="1">
                p.PushFieldmap(len(ft.Fields))
                for _, f := range ft.Fields </span><span class="cov8" title="1">{
                        nrv := rv.FieldByIndex(f.structField.Index)
                        if f.Type.isZero(nrv) </span><span class="cov8" title="1">{
                                if f.Nonzero </span><span class="cov8" title="1">{
                                        p.Errorf("%w: %q", ErrZero, f.Name)
                                }</span>
                                <span class="cov8" title="1">p.Field(false)
                                // Pretend to pack to get the nonzero checks.
                                if nrv.IsValid() &amp;&amp; (nrv.Kind() != reflect.Ptr || !nrv.IsNil()) </span><span class="cov8" title="1">{
                                        f.Type.pack(&amp;packer{b: &amp;bytes.Buffer{}}, nrv)
                                }</span>
                        } else<span class="cov8" title="1"> {
                                p.Field(true)
                                f.Type.pack(p, nrv)
                        }</span>
                }
                <span class="cov8" title="1">p.PopFieldmap()</span>
        default:<span class="cov0" title="0">
                p.Errorf("internal error: unhandled field type")</span> // should be prevented when registering type
        }
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package bstore

import (
        "encoding"
        "encoding/binary"
        "fmt"
        "math"
        "reflect"
        "time"
)

type parser struct {
        buf  []byte
        orig []byte
}

func (p *parser) Errorf(format string, args ...any) <span class="cov0" title="0">{
        panic(parseErr{fmt.Errorf(format, args...)})</span>
}

func (p *parser) checkInt(un uint64) int <span class="cov8" title="1">{
        if un &gt; math.MaxInt32 </span><span class="cov0" title="0">{
                p.Errorf("%w: uvarint %d does not fit in int32", ErrStore, un)
        }</span>
        <span class="cov8" title="1">return int(un)</span>
}

// Fieldmap starts a new fieldmap for n fields.
func (p *parser) Fieldmap(n int) *fieldmap <span class="cov8" title="1">{
        // log.Printf("parse fieldmap %d bits", n)
        nb := (n + 7) / 8
        buf := p.Take(nb)
        return &amp;fieldmap{n, buf, 0, 0, p.Errorf}
}</span>

// Take reads nb bytes.
func (p *parser) Take(nb int) []byte <span class="cov8" title="1">{
        // log.Printf("take %d", nb)
        if len(p.buf) &lt; nb </span><span class="cov0" title="0">{
                p.Errorf("%w: not enough bytes", ErrStore)
        }</span>
        <span class="cov8" title="1">buf := p.buf[:nb]
        p.buf = p.buf[nb:]
        return buf</span>
}

// TakeBytes reads a uvarint representing the size of the bytes, followed by
// that number of bytes.
// dup is needed if you need to hold on to the bytes. Values from BoltDB are
// only valid in the transaction, and not meant to be modified and are
// memory-mapped read-only.
func (p *parser) TakeBytes(dup bool) []byte <span class="cov8" title="1">{
        un := p.Uvarint()
        n := p.checkInt(un)
        buf := p.Take(n)
        if dup </span><span class="cov8" title="1">{
                // todo: check for a max size, beyond which we refuse to allocate?
                nbuf := make([]byte, len(buf))
                copy(nbuf, buf)
                buf = nbuf
        }</span>
        <span class="cov8" title="1">return buf</span>
}

func (p *parser) Uvarint() uint64 <span class="cov8" title="1">{
        v, n := binary.Uvarint(p.buf)
        if n == 0 </span><span class="cov0" title="0">{
                p.Errorf("%w: uvarint: not enough bytes", ErrStore)
        }</span>
        <span class="cov8" title="1">if n &lt; 0 </span><span class="cov0" title="0">{
                p.Errorf("%w: uvarint overflow", ErrStore)
        }</span>
        // log.Printf("take uvarint, %d bytes", n)
        <span class="cov8" title="1">p.buf = p.buf[n:]
        return v</span>
}

func (p *parser) Varint() int64 <span class="cov8" title="1">{
        v, n := binary.Varint(p.buf)
        if n == 0 </span><span class="cov0" title="0">{
                p.Errorf("%w: varint: not enough bytes", ErrStore)
        }</span>
        <span class="cov8" title="1">if n &lt; 0 </span><span class="cov0" title="0">{
                p.Errorf("%w: varint overflow", ErrStore)
        }</span>
        // log.Printf("take varint, %d bytes", n)
        <span class="cov8" title="1">p.buf = p.buf[n:]
        return v</span>
}

type parseErr struct {
        err error
}

// parse rv (reflect.Struct) from buf.
// does not part primary key field.
func (st storeType) parse(rv reflect.Value, buf []byte) (rerr error) <span class="cov8" title="1">{
        p := &amp;parser{buf: buf, orig: buf}
        var version uint32
        defer func() </span><span class="cov8" title="1">{
                x := recover()
                if x == nil </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov0" title="0">perr, ok := x.(parseErr)
                if ok </span><span class="cov0" title="0">{
                        rerr = fmt.Errorf("%w (version %d, buf %x, orig %x)", perr.err, version, p.buf, p.orig)
                        return
                }</span>
                <span class="cov0" title="0">panic(x)</span>
        }()

        <span class="cov8" title="1">version = uint32(p.Uvarint())
        tv, ok := st.Versions[version]
        if !ok </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: unknown type version %d", ErrStore, version)
        }</span>

        <span class="cov8" title="1">tv.parse(p, rv)

        if len(p.buf) != 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("%w: leftover data after parsing", ErrStore)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// parseNew parses bk and bv into a newly created value of type st.Type.
func (st storeType) parseNew(bk, bv []byte) (reflect.Value, error) <span class="cov8" title="1">{
        rv := reflect.New(st.Type).Elem()
        if err := st.parseFull(rv, bk, bv); err != nil </span><span class="cov0" title="0">{
                return reflect.Value{}, err
        }</span>
        <span class="cov8" title="1">return rv, nil</span>
}

// parseFull parses a full record from bk and bv into value rv, which must be
// of type st.Type.
func (st storeType) parseFull(rv reflect.Value, bk, bv []byte) error <span class="cov8" title="1">{
        if err := parsePK(rv.Field(0), bk); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">err := st.parse(rv, bv)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (tv typeVersion) parse(p *parser, rv reflect.Value) <span class="cov8" title="1">{
        // First field is the primary key, stored as boltdb key only, not in
        // the value.
        fm := p.Fieldmap(len(tv.Fields) - 1)
        for i, f := range tv.Fields[1:] </span><span class="cov8" title="1">{
                if f.structField.Type == nil </span><span class="cov8" title="1">{
                        // Do not parse this field in the current Go type, but
                        // we must still skip over the bytes.
                        if fm.Nonzero(i) </span><span class="cov8" title="1">{
                                f.Type.skip(p)
                        }</span>
                        <span class="cov8" title="1">continue</span>
                }
                <span class="cov8" title="1">if fm.Nonzero(i) </span><span class="cov8" title="1">{
                        f.Type.parse(p, rv.FieldByIndex(f.structField.Index))
                }</span> else<span class="cov8" title="1"> if f.Nonzero </span><span class="cov0" title="0">{
                        // Consistency check. Should not happen, we enforce nonzeroness.
                        p.Errorf("%w: unexpected nonzero value for %q", ErrStore, f.Name)
                }</span> else<span class="cov8" title="1"> {
                        rv.FieldByIndex(f.structField.Index).Set(reflect.Zero(f.structField.Type))
                }</span>
        }
}

// parse a nonzero fieldType.
func (ft fieldType) parse(p *parser, rv reflect.Value) <span class="cov8" title="1">{
        // Because we allow schema changes from ptr to nonptr, rv can be a pointer or direct value regardless of ft.Ptr.
        if rv.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                nrv := reflect.New(rv.Type().Elem())
                rv.Set(nrv)
                rv = nrv.Elem()
        }</span>
        <span class="cov8" title="1">switch ft.Kind </span>{
        case kindBytes:<span class="cov8" title="1">
                rv.SetBytes(p.TakeBytes(true))</span>
        case kindBinaryMarshal:<span class="cov8" title="1">
                buf := p.TakeBytes(false)
                t := rv.Type()
                if t.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                        t = t.Elem()
                }</span>
                <span class="cov8" title="1">v := reflect.New(t)
                err := v.Interface().(encoding.BinaryUnmarshaler).UnmarshalBinary(buf)
                if err != nil </span><span class="cov0" title="0">{
                        panic(parseErr{err})</span>
                }
                <span class="cov8" title="1">if rv.Type().Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                        rv.Set(v)
                }</span> else<span class="cov8" title="1"> {
                        rv.Set(v.Elem())
                }</span>
        case kindBool:<span class="cov8" title="1">
                rv.SetBool(true)</span>
        case kindInt:<span class="cov8" title="1">
                v := p.Varint()
                if v &lt; math.MinInt32 || v &gt; math.MaxInt32 </span><span class="cov0" title="0">{
                        p.Errorf("%w: int %d does not fit in int32", ErrStore, v)
                }</span>
                <span class="cov8" title="1">rv.SetInt(v)</span>
        case kindInt8, kindInt16, kindInt32, kindInt64:<span class="cov8" title="1">
                rv.SetInt(p.Varint())</span>
        case kindUint:<span class="cov8" title="1">
                v := p.Uvarint()
                if v &gt; math.MaxUint32 </span><span class="cov0" title="0">{
                        p.Errorf("%w: uint %d does not fit in uint32", ErrStore, v)
                }</span>
                <span class="cov8" title="1">rv.SetUint(v)</span>
        case kindUint8, kindUint16, kindUint32, kindUint64:<span class="cov8" title="1">
                rv.SetUint(p.Uvarint())</span>
        case kindFloat32:<span class="cov8" title="1">
                rv.SetFloat(float64(math.Float32frombits(uint32(p.Uvarint()))))</span>
        case kindFloat64:<span class="cov8" title="1">
                rv.SetFloat(math.Float64frombits(p.Uvarint()))</span>
        case kindString:<span class="cov8" title="1">
                rv.SetString(string(p.TakeBytes(false)))</span>
        case kindTime:<span class="cov8" title="1">
                err := rv.Addr().Interface().(*time.Time).UnmarshalBinary(p.TakeBytes(false))
                if err != nil </span><span class="cov0" title="0">{
                        p.Errorf("%w: parsing time: %s", ErrStore, err)
                }</span>
        case kindSlice:<span class="cov8" title="1">
                un := p.Uvarint()
                n := p.checkInt(un)
                fm := p.Fieldmap(n)
                slc := reflect.MakeSlice(rv.Type(), n, n)
                for i := 0; i &lt; int(n); i++ </span><span class="cov8" title="1">{
                        if fm.Nonzero(i) </span><span class="cov8" title="1">{
                                ft.List.parse(p, slc.Index(i))
                        }</span>
                }
                <span class="cov8" title="1">rv.Set(slc)</span>
        case kindMap:<span class="cov8" title="1">
                un := p.Uvarint()
                n := p.checkInt(un)
                fm := p.Fieldmap(n)
                mp := reflect.MakeMapWithSize(rv.Type(), n)
                for i := 0; i &lt; n; i++ </span><span class="cov8" title="1">{
                        mk := reflect.New(rv.Type().Key()).Elem()
                        ft.MapKey.parse(p, mk)
                        mv := reflect.New(rv.Type().Elem()).Elem()
                        if fm.Nonzero(i) </span><span class="cov8" title="1">{
                                ft.MapValue.parse(p, mv)
                        }</span>
                        <span class="cov8" title="1">mp.SetMapIndex(mk, mv)</span>
                }
                <span class="cov8" title="1">rv.Set(mp)</span>
        case kindStruct:<span class="cov8" title="1">
                fm := p.Fieldmap(len(ft.Fields))
                strct := reflect.New(rv.Type()).Elem()
                for i, f := range ft.Fields </span><span class="cov8" title="1">{
                        if f.structField.Type == nil </span><span class="cov8" title="1">{
                                f.Type.skip(p)
                                continue</span>
                        }
                        <span class="cov8" title="1">if fm.Nonzero(i) </span><span class="cov8" title="1">{
                                f.Type.parse(p, strct.FieldByIndex(f.structField.Index))
                        }</span> else<span class="cov8" title="1"> if f.Nonzero </span><span class="cov0" title="0">{
                                // Consistency check, we enforce that nonzero is not stored if not allowed.
                                p.Errorf("%w: %q", ErrZero, f.Name)
                        }</span> else<span class="cov8" title="1"> {
                                strct.FieldByIndex(f.structField.Index).Set(reflect.Zero(f.structField.Type))
                        }</span>
                }
                <span class="cov8" title="1">rv.Set(strct)</span>
        default:<span class="cov0" title="0">
                p.Errorf("internal error: unhandled field type")</span> // should be prevented when registering type
        }
}

// skip over the bytes for this fieldType. Needed when an older typeVersion has
// a field that the current reflect.Type does not (can) have.
func (ft fieldType) skip(p *parser) <span class="cov8" title="1">{
        switch ft.Kind </span>{
        case kindBytes, kindBinaryMarshal, kindString:<span class="cov8" title="1">
                p.TakeBytes(false)</span>
        case kindBool:<span class="cov0" title="0"></span>
        case kindInt8, kindInt16, kindInt32, kindInt, kindInt64:<span class="cov8" title="1">
                p.Varint()</span>
        case kindUint8, kindUint16, kindUint32, kindUint, kindUint64, kindFloat32, kindFloat64:<span class="cov8" title="1">
                p.Uvarint()</span>
        case kindTime:<span class="cov8" title="1">
                p.TakeBytes(false)</span>
        case kindSlice:<span class="cov8" title="1">
                un := p.Uvarint()
                n := p.checkInt(un)
                fm := p.Fieldmap(n)
                for i := 0; i &lt; n; i++ </span><span class="cov8" title="1">{
                        if fm.Nonzero(i) </span><span class="cov8" title="1">{
                                ft.List.skip(p)
                        }</span>
                }
        case kindMap:<span class="cov8" title="1">
                un := p.Uvarint()
                n := p.checkInt(un)
                fm := p.Fieldmap(n)
                for i := 0; i &lt; n; i++ </span><span class="cov8" title="1">{
                        ft.MapKey.skip(p)
                        if fm.Nonzero(i) </span><span class="cov8" title="1">{
                                ft.MapValue.skip(p)
                        }</span>
                }
        case kindStruct:<span class="cov8" title="1">
                fm := p.Fieldmap(len(ft.Fields))
                for i, f := range ft.Fields </span><span class="cov8" title="1">{
                        if fm.Nonzero(i) </span><span class="cov8" title="1">{
                                f.Type.skip(p)
                        }</span>
                }
        default:<span class="cov0" title="0">
                p.Errorf("internal error: unhandled field type")</span> // should be prevented when registering type
        }
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package bstore

import (
        "bytes"
        "fmt"
        "reflect"
        "sort"
)

// Plan represents a plan to execute a query, possibly using a simple/quick
// bucket "get" or cursor scan (forward/backward) on either the records or an
// index.
type plan[T any] struct {
        // The index for this plan. If nil, we are using pk's, in which case
        // "keys" below can be nil for a range scan with start/stop (possibly empty
        // for full scan), or non-nil for looking up specific keys.
        idx *index

        // Use full unique index to get specific values from keys. idx above can be
        // a unique index that we only use partially. In that case, this field is
        // false.
        unique bool

        // If not nil, used to fetch explicit keys when using pk or unique
        // index. Required non-nil for unique.
        keys [][]byte

        desc           bool   // Direction of the range scan.
        start          []byte // First key to scan. Filters below may still apply. If desc, this value is &gt; than stop (if it is set). If nil, we begin ranging at the first or last (for desc) key.
        stop           []byte // Last key to scan. Can be nil independently of start.
        startInclusive bool   // If the start and stop values are inclusive or exclusive.
        stopInclusive  bool

        // Filter we need to apply on after retrieving the record. If all
        // original filters from a query were handled by "keys" above, or by a
        // range scan, this field is empty.
        filters []filter[T]

        // Orders we need to apply after first retrieving all records. As with
        // filters, if a range scan takes care of an ordering from the query,
        // this field is empty.
        orders []order
}

// selectPlan selects the best plan for this query.
func (q *Query[T]) selectPlan() (*plan[T], error) <span class="cov8" title="1">{
        // Simple case first: List of known IDs. We can just fetch them from
        // the records bucket by their primary keys. This is common for a
        // "Get" query.
        if q.xfilterIDs != nil </span><span class="cov8" title="1">{
                orders := q.xorders
                keys := q.xfilterIDs.pks
                // If there is an ordering on the PK field, we do the ordering here.
                if len(orders) &gt; 0 &amp;&amp; orders[0].field.Name == q.st.Current.Fields[0].Name </span><span class="cov8" title="1">{
                        asc := orders[0].asc
                        sort.Slice(keys, func(i, j int) bool </span><span class="cov8" title="1">{
                                cmp := bytes.Compare(keys[i], keys[j])
                                return asc &amp;&amp; cmp &lt; 0 || !asc &amp;&amp; cmp &gt; 0
                        }</span>)
                        <span class="cov8" title="1">orders = orders[1:]</span>
                }
                <span class="cov8" title="1">p := &amp;plan[T]{
                        keys:    keys,
                        filters: q.xfilters,
                        orders:  orders,
                }
                return p, nil</span>
        }

        // Try using a fully matched unique index. We build a map with all
        // fields that have an equal or in filter. So we can easily look
        // through our unique indices and get a match. We only look at a single
        // filter per field. If there are multiple, we would use the last one.
        // That's okay, we'll filter records out when we execute the leftover
        // filters. Probably not common.
        // This is common for filterEqual and filterIn on
        // fields that have a unique index.
        <span class="cov8" title="1">equalsIn := map[string]*filter[T]{}
        for i := range q.xfilters </span><span class="cov8" title="1">{
                ff := &amp;q.xfilters[i]
                switch f := (*ff).(type) </span>{
                case filterEqual[T]:<span class="cov8" title="1">
                        equalsIn[f.field.Name] = ff</span>
                case filterIn[T]:<span class="cov8" title="1">
                        equalsIn[f.field.Name] = ff</span>
                }
        }
<span class="cov8" title="1">indices:
        for _, idx := range q.st.Current.Indices </span><span class="cov8" title="1">{
                // Direct fetches only for unique indices.
                if !idx.Unique </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">for _, f := range idx.Fields </span><span class="cov8" title="1">{
                        if _, ok := equalsIn[f.Name]; !ok </span><span class="cov8" title="1">{
                                // At least one index field does not have a filter.
                                continue indices</span>
                        }
                }
                // Calculate all keys that we need to retrieve from the index.
                // todo optimization: if there is a sort involving these fields, we could do the sorting before fetching data.
                // todo optimization: we can generate the keys on demand, will help when limit is in use: we are not generating all keys.
                <span class="cov8" title="1">var keys [][]byte
                var skipFilters []*filter[T] // Filters to remove from the full list because they are handled by quering the index.
                for i, f := range idx.Fields </span><span class="cov8" title="1">{
                        var rvalues []reflect.Value
                        ff := equalsIn[f.Name]
                        skipFilters = append(skipFilters, ff)
                        switch fi := (*ff).(type) </span>{
                        case filterEqual[T]:<span class="cov8" title="1">
                                rvalues = []reflect.Value{fi.rvalue}</span>
                        case filterIn[T]:<span class="cov8" title="1">
                                rvalues = fi.rvalues</span>
                        default:<span class="cov0" title="0">
                                return nil, fmt.Errorf("internal error: bad filter %T", equalsIn[f.Name])</span>
                        }
                        <span class="cov8" title="1">fekeys := make([][]byte, len(rvalues))
                        for j, fv := range rvalues </span><span class="cov8" title="1">{
                                key, _, err := packIndexKeys([]reflect.Value{fv}, nil)
                                if err != nil </span><span class="cov0" title="0">{
                                        q.error(err)
                                        return nil, err
                                }</span>
                                <span class="cov8" title="1">fekeys[j] = key</span>
                        }
                        <span class="cov8" title="1">if i == 0 </span><span class="cov8" title="1">{
                                keys = fekeys
                                continue</span>
                        }
                        // Multiply current keys with the new values.
                        <span class="cov8" title="1">nkeys := make([][]byte, 0, len(keys)*len(fekeys))
                        for _, k := range keys </span><span class="cov8" title="1">{
                                for _, fk := range fekeys </span><span class="cov8" title="1">{
                                        nk := append(append([]byte{}, k...), fk...)
                                        nkeys = append(nkeys, nk)
                                }</span>
                        }
                        <span class="cov8" title="1">keys = nkeys</span>
                }
                <span class="cov8" title="1">p := &amp;plan[T]{
                        idx:     idx,
                        unique:  true,
                        keys:    keys,
                        filters: dropFilters(q.xfilters, skipFilters),
                        orders:  q.xorders,
                }
                return p, nil</span>
        }

        // Try all other indices. We treat them all as non-unique indices now.
        // We want to use the one with as many "equal" prefix fields as
        // possible. Then we hope to use a scan on the remaining, either
        // because of a filterCompare, or for an ordering. If there is a limit,
        // orderings are prefered over compares.
        <span class="cov8" title="1">equals := map[string]*filter[T]{}
        for i := range q.xfilters </span><span class="cov8" title="1">{
                ff := &amp;q.xfilters[i]
                switch f := (*ff).(type) </span>{
                case filterEqual[T]:<span class="cov8" title="1">
                        equals[f.field.Name] = ff</span>
                }
        }

        // We are going to generate new plans, and keep the new one if it is better than what we have.
        <span class="cov8" title="1">var p *plan[T]
        var nequals int
        var nrange int
        var ordered bool

        evaluatePKOrIndex := func(idx *index) error </span><span class="cov8" title="1">{
                var isPK bool
                var packKeys func([]reflect.Value) ([]byte, error)
                if idx == nil </span><span class="cov8" title="1">{
                        // Make pretend index.
                        isPK = true
                        idx = &amp;index{
                                Fields: []field{q.st.Current.Fields[0]},
                        }
                        packKeys = func(l []reflect.Value) ([]byte, error) </span><span class="cov8" title="1">{
                                return packPK(l[0])
                        }</span>
                } else<span class="cov8" title="1"> {
                        packKeys = func(l []reflect.Value) ([]byte, error) </span><span class="cov8" title="1">{
                                key, _, err := packIndexKeys(l, nil)
                                return key, err
                        }</span>
                }

                <span class="cov8" title="1">var neq = 0
                // log.Printf("idx %v", idx)
                var skipFilters []*filter[T]
                for _, f := range idx.Fields </span><span class="cov8" title="1">{
                        if ff, ok := equals[f.Name]; ok </span><span class="cov8" title="1">{
                                skipFilters = append(skipFilters, ff)
                                neq++
                        }</span> else<span class="cov8" title="1"> {
                                break</span>
                        }
                }

                // See if the next field can be used for compare.
                <span class="cov8" title="1">var gx, lx *filterCompare[T]
                var nrng int
                var order *order
                orders := q.xorders
                if neq &lt; len(idx.Fields) </span><span class="cov8" title="1">{
                        nf := idx.Fields[neq]
                        for i := range q.xfilters </span><span class="cov8" title="1">{
                                ff := &amp;q.xfilters[i]
                                switch f := (*ff).(type) </span>{
                                case filterCompare[T]:<span class="cov8" title="1">
                                        if f.field.Name != nf.Name </span><span class="cov8" title="1">{
                                                continue</span>
                                        }
                                        <span class="cov8" title="1">switch f.op </span>{
                                        case opGreater, opGreaterEqual:<span class="cov8" title="1">
                                                if gx == nil </span><span class="cov8" title="1">{
                                                        gx = &amp;f
                                                        skipFilters = append(skipFilters, ff)
                                                        nrng++
                                                }</span>
                                        case opLess, opLessEqual:<span class="cov8" title="1">
                                                if lx == nil </span><span class="cov8" title="1">{
                                                        lx = &amp;f
                                                        skipFilters = append(skipFilters, ff)
                                                        nrng++
                                                }</span>
                                        }
                                }
                        }

                        // See if it can be used for ordering.
                        // todo optimization: we could use multiple orders
                        <span class="cov8" title="1">if len(orders) &gt; 0 &amp;&amp; orders[0].field.Name == nf.Name </span><span class="cov8" title="1">{
                                order = &amp;orders[0]
                                orders = orders[1:]
                        }</span>
                }

                // See if this is better than what we had.
                <span class="cov8" title="1">if !(neq &gt; nequals || (neq == nequals &amp;&amp; (nrng &gt; nrange || order != nil &amp;&amp; !ordered &amp;&amp; (q.xlimit &gt; 0 || nrng == nrange)))) </span><span class="cov8" title="1">{
                        // log.Printf("plan not better, neq %d, nrng %d, limit %d, order %v ordered %v", neq, nrng, q.limit, order, ordered)
                        return nil
                }</span>
                <span class="cov8" title="1">nequals = neq
                nrange = nrng
                ordered = order != nil

                // Calculate the prefix key.
                var kvalues []reflect.Value
                for i := 0; i &lt; neq; i++ </span><span class="cov8" title="1">{
                        f := idx.Fields[i]
                        kvalues = append(kvalues, (*equals[f.Name]).(filterEqual[T]).rvalue)
                }</span>
                <span class="cov8" title="1">var key []byte
                var err error
                if neq &gt; 0 </span><span class="cov8" title="1">{
                        key, err = packKeys(kvalues)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov8" title="1">start := key
                stop := key
                if gx != nil </span><span class="cov8" title="1">{
                        k, err := packKeys([]reflect.Value{gx.value})
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">start = append(append([]byte{}, start...), k...)</span>
                }
                <span class="cov8" title="1">if lx != nil </span><span class="cov8" title="1">{
                        k, err := packKeys([]reflect.Value{lx.value})
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">stop = append(append([]byte{}, stop...), k...)</span>
                }

                <span class="cov8" title="1">startInclusive := gx == nil || gx.op != opGreater
                stopInclusive := lx == nil || lx.op != opLess
                if order != nil &amp;&amp; !order.asc </span><span class="cov8" title="1">{
                        start, stop = stop, start
                        startInclusive, stopInclusive = stopInclusive, startInclusive
                }</span>

                <span class="cov8" title="1">if isPK </span><span class="cov8" title="1">{
                        idx = nil // Clear our fake index for PK.
                }</span>

                <span class="cov8" title="1">p = &amp;plan[T]{
                        idx:            idx,
                        desc:           order != nil &amp;&amp; !order.asc,
                        start:          start,
                        stop:           stop,
                        startInclusive: startInclusive,
                        stopInclusive:  stopInclusive,
                        filters:        dropFilters(q.xfilters, skipFilters),
                        orders:         orders,
                }
                return nil</span>
        }

        <span class="cov8" title="1">if err := evaluatePKOrIndex(nil); err != nil </span><span class="cov0" title="0">{
                q.error(err)
                return nil, q.err
        }</span>
        <span class="cov8" title="1">for _, idx := range q.st.Current.Indices </span><span class="cov8" title="1">{
                if err := evaluatePKOrIndex(idx); err != nil </span><span class="cov0" title="0">{
                        q.error(err)
                        return nil, q.err
                }</span>

        }
        <span class="cov8" title="1">if p != nil </span><span class="cov8" title="1">{
                return p, nil
        }</span>

        // We'll just do a scan over all data.
        <span class="cov8" title="1">p = &amp;plan[T]{
                filters: q.xfilters,
                orders:  q.xorders,
        }
        return p, nil</span>
}

func dropFilters[T any](filters []T, skip []*T) []T <span class="cov8" title="1">{
        n := make([]T, 0, len(filters)-len(skip))
next:
        for i := range filters </span><span class="cov8" title="1">{
                f := &amp;filters[i]
                for _, s := range skip </span><span class="cov8" title="1">{
                        if f == s </span><span class="cov8" title="1">{
                                continue next</span>
                        }
                }
                <span class="cov8" title="1">n = append(n, *f)</span>
        }
        <span class="cov8" title="1">return n</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package bstore

import (
        "fmt"
        "reflect"
)

// The convention for handling a errors on a Query: methods that return a bool
// will have set q.err using q.error(), which does cleanup. If a method returns
// an error, q.error was not yet called, but usually will be called immediately
// after with the returned err, possibly first adding context.

// Query selects data for Go struct T based on filters, sorting, limits. The
// query is completed by calling an operation, such as Count, Get, List,
// Update, Delete, etc.
//
// Record selection functions like FilterEqual and Limit return the (modified)
// query itself, allowing chaining of calls.
//
// Queries are automatically closed after their operation, with two exceptions:
// After using Next and NextID on a query that did not yet return a non-nil
// error, you must call Close.
//
// A Query is not safe for concurrent use.
type Query[T any] struct {
        st         storeType     // Of T.
        pkType     reflect.Type  // Shortcut for st.Current.Fields[0].
        xtx        *Tx           // If nil, a new transaction is automatically created from db. Using a tx goes through tx() one exists.
        xdb        *DB           // If not nil, xtx was created to execute the operation and is when the operation finishes (also on error).
        err        error         // If set, returned by operations. For indicating failed filters, or that an operation has finished.
        xfilterIDs *filterIDs[T] // Kept separately from filters because these filters make us use the PK without further index planning.
        xfilters   []filter[T]
        xorders    []order

        // If 0, no limit has been set. Otherwise the number of IDs or records to
        // read. Set by limit calls, and set to 1 for an Exists.
        xlimit int

        // Set when Next/NextID is called. We prevent non-Next calls after that moment.
        // Should prevent unexpected results for users.
        nextOnly bool

        gatherIDs reflect.Value // Pointer to slice to pktype, for PKs of updated/deleted records.
        gathers   *[]T          // For full records of updated/deleted records.

        exec *exec[T]

        stats Stats
}

// sentinel interface to for sanity checking.
type filter[T any] interface {
        filter()
}

// filter by one or more IDs.
type filterIDs[T any] struct {
        ids map[any]struct{} // Regular values.
        pks [][]byte         // Packed values.
}

func (filterIDs[T]) filter() {<span class="cov0" title="0">}</span>

type filterFn[T any] struct {
        fn func(value T) bool // Function to call for each record, returning true if the record is selected.
}

func (filterFn[T]) filter() {<span class="cov0" title="0">}</span>

// Filter on field equality.
type filterEqual[T any] struct {
        field  field
        rvalue reflect.Value
}

func (filterEqual[T]) filter() {<span class="cov0" title="0">}</span>

// Filter on field non-equality.
type filterNotEqual[T any] struct {
        field  field
        rvalue reflect.Value
}

func (filterNotEqual[T]) filter() {<span class="cov0" title="0">}</span>

// Like filterEqual, but for one or more values.
type filterIn[T any] struct {
        field   field
        rvalues []reflect.Value
}

func (filterIn[T]) filter() {<span class="cov0" title="0">}</span>

// Like filterNonEqual, but for one or more values.
type filterNotIn[T any] struct {
        field   field
        rvalues []reflect.Value
}

func (filterNotIn[T]) filter() {<span class="cov0" title="0">}</span>

type compareOp byte

const (
        opGreater compareOp = iota
        opGreaterEqual
        opLess
        opLessEqual
)

// filter by comparison.
type filterCompare[T any] struct {
        field field
        op    compareOp
        value reflect.Value
}

func (filterCompare[T]) filter() {<span class="cov0" title="0">}</span>

// ordering of result.
type order struct {
        field field
        asc   bool
}

// Pair represents a primary key with lazily loaded record data. When user only
// cares about IDs we don't have to parse the full record. And if we go through
// in index we don't have to fetch the full record either.
type pair[T any] struct {
        bk    []byte
        bv    []byte // If nil, data must be loaded.
        value *T     // If not nil, the parsed form of bv.
}

// Value returns a fully parsed record. It first fetches the record data if not
// yet present.
func (p *pair[T]) Value(e *exec[T]) (T, error) <span class="cov8" title="1">{
        var zero T
        if p.value != nil </span><span class="cov8" title="1">{
                return *p.value, nil
        }</span>
        <span class="cov8" title="1">if p.bv == nil </span><span class="cov8" title="1">{
                e.q.stats.Records.Get++
                p.bv = e.rb.Get(p.bk)
                if p.bv == nil </span><span class="cov0" title="0">{
                        return zero, fmt.Errorf("%w: no data for key", ErrStore)
                }</span>
        }
        <span class="cov8" title="1">var v T
        err := e.q.st.parseFull(reflect.ValueOf(&amp;v).Elem(), p.bk, p.bv)
        if err != nil </span><span class="cov0" title="0">{
                return zero, err
        }</span>
        <span class="cov8" title="1">p.value = &amp;v
        return v, nil</span>
}

// QueryDB returns a new Query for type T. When an operation on the query is
// executed, a read-only/writable transaction is created as appropriate for the
// operation.
func QueryDB[T any](db *DB) *Query[T] <span class="cov8" title="1">{
        // We lock db for storeTypes. We keep it locked until Query is done.
        db.typesMutex.RLock()
        q := &amp;Query[T]{xdb: db}
        q.init(db)
        return q
}</span>

// Query returns a new Query that operates on type T using transaction tx.
func QueryTx[T any](tx *Tx) *Query[T] <span class="cov8" title="1">{
        // note: Since we are in a transaction, we already hold an rlock on the
        // db types.
        q := &amp;Query[T]{xtx: tx}
        q.init(tx.db)
        return q
}</span>

// Stats returns the current statistics for this query. When a query finishes,
// its stats are added to those of its transaction. When a transaction
// finishes, its stats are added to those of its database.
func (q *Query[T]) Stats() Stats <span class="cov0" title="0">{
        return q.stats
}</span>

func (q *Query[T]) init(db *DB) <span class="cov8" title="1">{
        var v T
        t := reflect.TypeOf(v)
        if t.Kind() != reflect.Struct </span><span class="cov8" title="1">{
                q.errorf("%w: type must be struct, not pointer or other type", ErrType)
                return
        }</span>
        <span class="cov8" title="1">q.st, q.err = db.storeType(t)
        if q.err == nil </span><span class="cov8" title="1">{
                q.stats.LastType = q.st.Name
                q.pkType = q.st.Current.Fields[0].structField.Type
        }</span>
}

func (q *Query[T]) tx(write bool) (*Tx, error) <span class="cov8" title="1">{
        if q.xtx == nil </span><span class="cov8" title="1">{
                if q.xdb == nil </span><span class="cov0" title="0">{
                        q.errorf("%w: missing db and tx: use QueryDB or QueryTx to make a new Query", ErrParam)
                        return nil, q.err
                }</span>
                <span class="cov8" title="1">tx, err := q.xdb.bdb.Begin(write)
                if err != nil </span><span class="cov0" title="0">{
                        q.error(err)
                        return nil, q.err
                }</span>
                <span class="cov8" title="1">q.xtx = &amp;Tx{db: q.xdb, btx: tx}
                if write </span><span class="cov8" title="1">{
                        q.stats.Writes++
                }</span> else<span class="cov8" title="1"> {
                        q.stats.Reads++
                }</span>
        }
        <span class="cov8" title="1">return q.xtx, nil</span>
}

// error sets an error for the query, to be returned when next operations are executed.
// All Query instances go through this function for proper rollback and/or runlock
// as needed. If a query finished successfully, ErrFinished is set.
func (q *Query[T]) error(err error) <span class="cov8" title="1">{
        if q.xtx != nil &amp;&amp; q.xdb != nil </span><span class="cov8" title="1">{
                txerr := q.xtx.btx.Rollback()
                if sanityChecks &amp;&amp; txerr != nil </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("xtx rollback: %v", txerr))</span>
                }
                <span class="cov8" title="1">q.dbAddStats()
                q.xtx = nil</span>
        }
        <span class="cov8" title="1">if q.xdb != nil </span><span class="cov8" title="1">{
                q.xdb.typesMutex.RUnlock()
                q.xdb = nil
        }</span>
        <span class="cov8" title="1">if q.xtx != nil </span><span class="cov8" title="1">{
                q.txAddStats()
        }</span>
        // This is the only place besides init that sets an error on query.
        <span class="cov8" title="1">q.err = err</span>
}

// errorf calls error with a formatted error.
func (q *Query[T]) errorf(format string, args ...any) <span class="cov8" title="1">{
        q.error(fmt.Errorf(format, args...))
}</span>

// Close closes a Query. Must always be called for Queries on which Next or
// NextID was called. Other operations call Close themselves.
func (q *Query[T]) Close() error <span class="cov8" title="1">{
        var err error
        if q.xtx != nil &amp;&amp; q.xdb != nil </span><span class="cov0" title="0">{
                err = q.xtx.btx.Rollback()
                q.dbAddStats()
                q.xtx = nil
        }</span>
        <span class="cov8" title="1">q.error(ErrFinished)
        return err</span>
}

// txAddStats adds stats to a transaction that Query did not create.
func (q *Query[T]) txAddStats() <span class="cov8" title="1">{
        q.xtx.stats.add(q.stats)
        q.stats = Stats{}
}</span>

// dbAddStats adds stats to the database directly, because Query created the
// transaction and the tx is never exposed, so no need to go through it.
func (q *Query[T]) dbAddStats() <span class="cov8" title="1">{
        q.xdb.statsMutex.Lock()
        q.xdb.stats.add(q.stats)
        q.xdb.statsMutex.Unlock()
        q.stats = Stats{}
}</span>

// Operations that will do database operations get a defer call to this finish
// function, to ensure we also close transactions that we made.
func (q *Query[T]) finish(rerr *error) <span class="cov8" title="1">{
        if q.xtx != nil &amp;&amp; q.xdb != nil </span><span class="cov8" title="1">{
                if *rerr == nil &amp;&amp; q.xtx.btx.Writable() </span><span class="cov8" title="1">{
                        if err := q.xtx.btx.Commit(); err != nil </span><span class="cov0" title="0">{
                                *rerr = err
                        }</span>
                } else<span class="cov8" title="1"> if err := q.xtx.btx.Rollback(); err != nil &amp;&amp; sanityChecks </span><span class="cov0" title="0">{
                        panic(fmt.Errorf("rolling back: %v", err))</span>
                }
                <span class="cov8" title="1">q.dbAddStats()
                q.xtx = nil</span>
        }
        <span class="cov8" title="1">x := recover()
        if x != nil </span><span class="cov8" title="1">{
                q.errorf("%v", x)
                panic(x)</span>
        }
        <span class="cov8" title="1">q.error(ErrFinished)</span>
}

// checkNotNext is called by all operations except Next and NextID to ensure
// that the user does not mix Next/NextID with regular operations.
func (q *Query[T]) checkNotNext() <span class="cov8" title="1">{
        if q.err == nil &amp;&amp; q.nextOnly </span><span class="cov8" title="1">{
                q.errorf("%w: can only use further Next calls", ErrParam)
        }</span>
}

func (q *Query[T]) checkErr() bool <span class="cov8" title="1">{
        if q.err == nil &amp;&amp; q.xtx == nil &amp;&amp; q.xdb == nil </span><span class="cov8" title="1">{
                // Probably the result of using a Query zero value.
                q.errorf("%w: invalid query, use QueryDB or QueryTx to make a query", ErrParam)
        }</span>
        <span class="cov8" title="1">return q.err == nil</span>
}

func (q *Query[T]) addFilter(f filter[T]) <span class="cov8" title="1">{
        q.xfilters = append(q.xfilters, f)
}</span>

// nextKey returns the key and optionally value for the next matching record.
// If there is no more matching record, ErrAbsent is returned and the query
// finished. ErrAbsent should be set on the query by the calling operation if
// appropriate (but not for Update/Delete, because it would prevent further
// operations on the query and its transaction).
//
// The actual work is handled by executing a query plan. One is created on the
// first call, and the nextKey is forwarded to the plan execution thereafter.
//
// write indicates if a writable tx needs to be created (if any) for the
// operation that is initiating this data selection.
//
// value indicates if a full record should be parsed and returned, as opposed
// to only the PK. Some callers only care about the IDs of records, which can
// be handled more efficiently when going through an index.
func (q *Query[T]) nextKey(write, value bool) ([]byte, T, error) <span class="cov8" title="1">{
        if q.exec == nil </span><span class="cov8" title="1">{
                p, err := q.selectPlan()
                if err != nil </span><span class="cov0" title="0">{
                        q.error(err)
                        var zero T
                        return nil, zero, err
                }</span>
                // log.Printf("plan %#v", p)
                <span class="cov8" title="1">q.exec = p.exec(q)</span>
        }
        <span class="cov8" title="1">return q.exec.nextKey(write, value)</span>
}

// fetch the PK of the next selected record, and parse into pkv.
func (q *Query[T]) nextID(write bool, pkv reflect.Value) error <span class="cov8" title="1">{
        bk, _, err := q.nextKey(write, false)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return parsePK(pkv, bk)</span>
}

// foreachKey calls fn on each selected record. If value is set, fn's v is set,
// otherwise the zero value.
func (q *Query[T]) foreachKey(write, value bool, fn func(bk []byte, v T) error) error <span class="cov8" title="1">{
        if q.err != nil </span><span class="cov0" title="0">{
                return q.err
        }</span>
        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                bk, v, err := q.nextKey(write, value)
                if err == ErrAbsent </span><span class="cov8" title="1">{
                        return nil
                }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span> else<span class="cov8" title="1"> if err := fn(bk, v); err != nil </span><span class="cov8" title="1">{
                        q.error(err)
                        return err
                }</span>
        }
}

// foreachID calls fn with the primary key value for each selected record.
func (q *Query[T]) foreachID(write bool, fn func(pkv any) error) error <span class="cov8" title="1">{
        if q.err != nil </span><span class="cov0" title="0">{
                return q.err
        }</span>
        <span class="cov8" title="1">v := reflect.New(q.pkType).Elem()
        for </span><span class="cov8" title="1">{
                err := q.nextID(write, v)
                if err == ErrAbsent </span><span class="cov8" title="1">{
                        return nil
                }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span> else<span class="cov8" title="1"> if err := fn(v.Interface()); err != nil </span><span class="cov0" title="0">{
                        q.error(err)
                        return err
                }</span>
        }
}

// lookup field name in the current typeVersion.
func (q *Query[T]) lookupField(name string) (field, bool) <span class="cov8" title="1">{
        for _, ff := range q.st.Current.Fields </span><span class="cov8" title="1">{
                if ff.Name == name </span><span class="cov8" title="1">{
                        return ff, true
                }</span>
        }
        <span class="cov8" title="1">q.errorf("%w: unknown field %q", ErrParam, name)
        return field{}, false</span>
}

// Kinds that can be converted without loss of precision, identity is not in here.
type convertKinds struct{ from, to kind }

var convertFieldKinds = map[convertKinds]struct{}{
        {kindInt8, kindInt16}:  {},
        {kindInt8, kindInt32}:  {},
        {kindInt8, kindInt64}:  {},
        {kindInt8, kindInt}:    {},
        {kindInt16, kindInt32}: {},
        {kindInt16, kindInt64}: {},
        {kindInt16, kindInt}:   {},
        {kindInt32, kindInt}:   {},
        {kindInt32, kindInt64}: {},
        {kindInt, kindInt32}:   {},
        {kindInt, kindInt64}:   {},

        {kindUint8, kindUint16}:  {},
        {kindUint8, kindUint32}:  {},
        {kindUint8, kindUint64}:  {},
        {kindUint8, kindUint}:    {},
        {kindUint16, kindUint32}: {},
        {kindUint16, kindUint64}: {},
        {kindUint16, kindUint}:   {},
        {kindUint32, kindUint}:   {},
        {kindUint32, kindUint64}: {},
        {kindUint, kindUint32}:   {},
        {kindUint, kindUint64}:   {},

        {kindFloat32, kindFloat64}: {},
}

// Check type of value for field and return a reflect value that can directly be set on the field.
// If the field is a pointer, we allow non-pointers and convert them.
// We require value to be of a type that can be converted without loss of precision to the type of field.
func (q *Query[T]) prepareValue(fname string, ft fieldType, sf reflect.StructField, rv reflect.Value) (reflect.Value, bool) <span class="cov8" title="1">{
        if !rv.IsValid() </span><span class="cov8" title="1">{
                q.errorf("%w: invalid value", ErrParam)
                return rv, false
        }</span>
        // Quick check first.
        <span class="cov8" title="1">t := rv.Type()
        if t == sf.Type </span><span class="cov8" title="1">{
                return rv, true
        }</span>
        <span class="cov8" title="1">if !ft.Ptr &amp;&amp; rv.Kind() == reflect.Ptr </span><span class="cov0" title="0">{
                q.errorf("%w: cannot set ptr value to nonptr field", ErrParam)
                return rv, false
        }</span>

        <span class="cov8" title="1">k, err := typeKind(t)
        if err != nil </span><span class="cov8" title="1">{
                q.errorf("%w: type of field: %s", ErrParam, err)
                return reflect.Value{}, false
        }</span>
        <span class="cov8" title="1">if _, ok := convertFieldKinds[convertKinds{k, ft.Kind}]; !ok &amp;&amp; k != ft.Kind </span><span class="cov8" title="1">{
                q.errorf("%w: got %v for field %q, need %v", ErrParam, rv.Type(), fname, ft.Kind)
                return reflect.Value{}, false
        }</span>
        <span class="cov8" title="1">if k != ft.Kind </span><span class="cov8" title="1">{
                dt := sf.Type
                if ft.Ptr </span><span class="cov8" title="1">{
                        dt = dt.Elem()
                }</span>
                <span class="cov8" title="1">rv = rv.Convert(dt)</span>
        }
        <span class="cov8" title="1">if ft.Ptr &amp;&amp; rv.Kind() != reflect.Ptr </span><span class="cov8" title="1">{
                nv := reflect.New(sf.Type.Elem())
                nv.Elem().Set(rv)
                rv = nv
        }</span>
        <span class="cov8" title="1">return rv, true</span>
}

// checkPK checks if t is the type of the current typeVersion's PK, and returns
// a userfriendly error message otherwise.
func (q *Query[T]) checkPK(t reflect.Type) bool <span class="cov8" title="1">{
        if t != q.pkType </span><span class="cov8" title="1">{
                q.errorf("%w: id type was %s, must be %s", ErrParam, t, q.pkType)
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}

// FilterID selects the records with primary key id, which must be of the type
// of T's primary key.
func (q *Query[T]) FilterID(id any) *Query[T] <span class="cov8" title="1">{
        if !q.checkErr() </span><span class="cov0" title="0">{
                return q
        }</span>
        <span class="cov8" title="1">kv := reflect.ValueOf(id)
        if !q.checkPK(kv.Type()) </span><span class="cov0" title="0">{
                return q
        }</span>
        <span class="cov8" title="1">pk, err := packPK(kv)
        if err != nil </span><span class="cov0" title="0">{
                q.error(err)
                return q
        }</span>

        <span class="cov8" title="1">if q.xfilterIDs != nil </span><span class="cov8" title="1">{
                // Intersection of this ID with the previous IDs. Either it is this single ID or the list becomes empty.
                if _, ok := q.xfilterIDs.ids[id]; !ok </span><span class="cov8" title="1">{
                        q.xfilterIDs = &amp;filterIDs[T]{map[any]struct{}{}, [][]byte{}}
                        return q
                }</span>
        }
        <span class="cov8" title="1">q.xfilterIDs = &amp;filterIDs[T]{map[any]struct{}{id: {}}, [][]byte{pk}}
        return q</span>
}

// FilterIDs selects the records with a primary key that is in ids. Ids must be
// a slice of T's primary key type.
func (q *Query[T]) FilterIDs(ids any) *Query[T] <span class="cov8" title="1">{
        if !q.checkErr() </span><span class="cov0" title="0">{
                return q
        }</span>
        <span class="cov8" title="1">kv := reflect.ValueOf(ids)
        if kv.Kind() != reflect.Slice </span><span class="cov8" title="1">{
                q.errorf("%w: ids must be slice of %v, not %T", ErrParam, q.pkType, ids)
                return q
        }</span>
        <span class="cov8" title="1">if !q.checkPK(kv.Type().Elem()) </span><span class="cov8" title="1">{
                return q
        }</span>

        <span class="cov8" title="1">n := kv.Len()
        pks := make([][]byte, 0, n)
        var prevIDs map[any]struct{}
        if q.xfilterIDs != nil </span><span class="cov8" title="1">{
                prevIDs = q.xfilterIDs.ids // We use this to check intersection.
        }</span>
        // todo: should we fail for a zero PK?
        <span class="cov8" title="1">nids := map[any]struct{}{}
        for i := 0; i &lt; n; i++ </span><span class="cov8" title="1">{
                rev := kv.Index(i)
                ev := rev.Interface()
                if _, ok := prevIDs[ev]; !ok &amp;&amp; prevIDs != nil </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">nids[ev] = struct{}{}
                pk, err := packPK(rev)
                if err != nil </span><span class="cov0" title="0">{
                        q.error(err)
                        return q
                }</span>
                <span class="cov8" title="1">pks = append(pks, pk)</span>
        }
        <span class="cov8" title="1">q.xfilterIDs = &amp;filterIDs[T]{nids, pks}
        return q</span>
}

// FilterFn calls fn for each record selected so far. If fn returns true, the
// record is kept for further filters and finally the operation.
func (q *Query[T]) FilterFn(fn func(value T) bool) *Query[T] <span class="cov8" title="1">{
        if !q.checkErr() </span><span class="cov0" title="0">{
                return q
        }</span>
        <span class="cov8" title="1">if fn == nil </span><span class="cov8" title="1">{
                q.errorf("%w: nil fn", ErrParam)
                return q
        }</span>
        <span class="cov8" title="1">q.addFilter(filterFn[T]{fn})
        return q</span>
}

// gatherNonzeroFields returns fields and values that are non-zero. Used for
// Update and FilterNonzero.
//
// allowID indicates if the primary key is allowed to be nonzero (not for
// Updates).
//
// At least one field must be nonzero.
func gatherNonzeroFields(tv *typeVersion, rv reflect.Value, allowID bool) ([]field, []reflect.Value, error) <span class="cov8" title="1">{
        var fields []field
        var values []reflect.Value

        for i, f := range tv.Fields </span><span class="cov8" title="1">{
                fv := rv.FieldByIndex(f.structField.Index)
                if f.Type.isZero(fv) </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if i == 0 &amp;&amp; !allowID </span><span class="cov8" title="1">{
                        return nil, nil, fmt.Errorf("%w: primary key must be zero", ErrParam)
                }</span>
                <span class="cov8" title="1">fields = append(fields, f)
                values = append(values, fv)</span>
        }
        <span class="cov8" title="1">if len(fields) == 0 </span><span class="cov8" title="1">{
                return nil, nil, fmt.Errorf("%w: must have at least one nonzero field", ErrParam)
        }</span>
        <span class="cov8" title="1">return fields, values, nil</span>
}

// FilterNonzero gathers the nonzero fields from value, and selects records that
// have equal values for those fields. At least one value must be nonzero.
//
// Keep in mind that filtering on an embed/anonymous field looks at individual
// fields in the embedded field for non-zeroness, not at the embed field as a whole.
func (q *Query[T]) FilterNonzero(value T) *Query[T] <span class="cov8" title="1">{
        if !q.checkErr() </span><span class="cov0" title="0">{
                return q
        }</span>
        <span class="cov8" title="1">fields, values, err := gatherNonzeroFields(q.st.Current, reflect.ValueOf(value), true)
        if err != nil </span><span class="cov8" title="1">{
                q.error(err)
                return q
        }</span>
        <span class="cov8" title="1">for i, f := range fields </span><span class="cov8" title="1">{
                if f.Name == q.st.Current.Fields[0].Name </span><span class="cov8" title="1">{
                        q.FilterID(values[i].Interface())
                }</span> else<span class="cov8" title="1"> {
                        q.addFilter(filterEqual[T]{f, values[i]})
                }</span>
        }
        <span class="cov8" title="1">return q</span>
}

// FilterEqual selects records that have one of values for fieldName.
//
// Note: Value must be a compatible type for comparison with fieldName. Go
// constant numbers become ints, which are not compatible with uint or float
// types.
func (q *Query[T]) FilterEqual(fieldName string, values ...any) *Query[T] <span class="cov8" title="1">{
        q.filterEqual(fieldName, values, false)
        return q
}</span>

// FilterNotEqual selects records that do not have any of values for fieldName.
func (q *Query[T]) FilterNotEqual(fieldName string, values ...any) *Query[T] <span class="cov8" title="1">{
        q.filterEqual(fieldName, values, true)
        return q
}</span>

func (q *Query[T]) filterEqual(fieldName string, values []any, not bool) <span class="cov8" title="1">{
        if !q.checkErr() </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">ff, ok := q.lookupField(fieldName)
        if !ok </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if len(values) == 0 </span><span class="cov8" title="1">{
                q.errorf("%w: need at least one value for (not) equal", ErrParam)
                return
        }</span>
        <span class="cov8" title="1">if ff.Type.Ptr </span><span class="cov8" title="1">{
                q.errorf("%w: cannot compare pointer values", ErrParam)
                return
        }</span>
        <span class="cov8" title="1">if len(values) == 1 </span><span class="cov8" title="1">{
                rv, ok := q.prepareValue(ff.Name, ff.Type, ff.structField, reflect.ValueOf(values[0]))
                if !ok </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">if not </span><span class="cov8" title="1">{
                        q.addFilter(filterNotEqual[T]{ff, rv})
                }</span> else<span class="cov8" title="1"> {
                        q.addFilter(filterEqual[T]{ff, rv})
                }</span>
                <span class="cov8" title="1">return</span>
        }
        <span class="cov8" title="1">rvs := make([]reflect.Value, len(values))
        for i, value := range values </span><span class="cov8" title="1">{
                rv, ok := q.prepareValue(ff.Name, ff.Type, ff.structField, reflect.ValueOf(value))
                if !ok </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="1">rvs[i] = rv</span>
        }
        <span class="cov8" title="1">if not </span><span class="cov8" title="1">{
                q.addFilter(filterNotIn[T]{ff, rvs})
        }</span> else<span class="cov8" title="1"> {
                q.addFilter(filterIn[T]{ff, rvs})
        }</span>
}

// FilterGreater selects records that have fieldName &gt; value.
//
// Note: Value must be a compatible type for comparison with fieldName. Go
// constant numbers become ints, which are not compatible with uint or float
// types.
func (q *Query[T]) FilterGreater(fieldName string, value any) *Query[T] <span class="cov8" title="1">{
        return q.filterCompare(fieldName, opGreater, reflect.ValueOf(value))
}</span>

// FilterGreaterEqual selects records that have fieldName &gt;= value.
func (q *Query[T]) FilterGreaterEqual(fieldName string, value any) *Query[T] <span class="cov8" title="1">{
        return q.filterCompare(fieldName, opGreaterEqual, reflect.ValueOf(value))
}</span>

// FilterLess selects records that have fieldName &lt; value.
func (q *Query[T]) FilterLess(fieldName string, value any) *Query[T] <span class="cov8" title="1">{
        return q.filterCompare(fieldName, opLess, reflect.ValueOf(value))
}</span>

// FilterLessEqual selects records that have fieldName &lt;= value.
func (q *Query[T]) FilterLessEqual(fieldName string, value any) *Query[T] <span class="cov8" title="1">{
        return q.filterCompare(fieldName, opLessEqual, reflect.ValueOf(value))
}</span>

func (q *Query[T]) filterCompare(fieldName string, op compareOp, value reflect.Value) *Query[T] <span class="cov8" title="1">{
        if !q.checkErr() </span><span class="cov0" title="0">{
                return q
        }</span>
        <span class="cov8" title="1">ff, ok := q.lookupField(fieldName)
        if !ok </span><span class="cov8" title="1">{
                return q
        }</span>
        <span class="cov8" title="1">if !comparable(ff.Type) </span><span class="cov8" title="1">{
                q.errorf("%w: cannot compare %s", ErrParam, ff.Type.Kind)
                return q
        }</span>
        <span class="cov8" title="1">rv, ok := q.prepareValue(ff.Name, ff.Type, ff.structField, value)
        if !ok </span><span class="cov8" title="1">{
                return q
        }</span>
        <span class="cov8" title="1">q.addFilter(filterCompare[T]{ff, op, rv})
        return q</span>
}

// Limit stops selecting records after the first n records.
// Can only be called once. n must be &gt; 1.
func (q *Query[T]) Limit(n int) *Query[T] <span class="cov8" title="1">{
        if !q.checkErr() </span><span class="cov0" title="0">{
                return q
        }</span>
        <span class="cov8" title="1">if n &lt;= 0 </span><span class="cov8" title="1">{
                q.errorf("%w: limit must be &gt;= 1", ErrParam)
                return q
        }</span>
        <span class="cov8" title="1">if q.xlimit &gt; 0 </span><span class="cov8" title="1">{
                q.errorf("%w: already have a limit", ErrParam)
                return q
        }</span>
        <span class="cov8" title="1">q.xlimit = n
        return q</span>
}

// SortAsc sorts the selected records by fieldNames in ascending order.
// Additional orderings can be added by more calls to SortAsc or SortDesc.
func (q *Query[T]) SortAsc(fieldNames ...string) *Query[T] <span class="cov8" title="1">{
        return q.order(fieldNames, true)
}</span>

// SortDesc sorts the selected records by fieldNames in descending order.
// Additional orderings can be added by more calls to SortAsc or SortDesc.
func (q *Query[T]) SortDesc(fieldNames ...string) *Query[T] <span class="cov8" title="1">{
        return q.order(fieldNames, false)
}</span>

func (q *Query[T]) order(fieldNames []string, asc bool) *Query[T] <span class="cov8" title="1">{
        if !q.checkErr() </span><span class="cov0" title="0">{
                return q
        }</span>
        <span class="cov8" title="1">if len(fieldNames) == 0 </span><span class="cov8" title="1">{
                q.errorf("%w: sort fieldNames must be non-empty", ErrParam)
                return q
        }</span>
        <span class="cov8" title="1">for _, name := range fieldNames </span><span class="cov8" title="1">{
                ff, ok := q.lookupField(name)
                if !ok </span><span class="cov0" title="0">{
                        return q
                }</span>
                <span class="cov8" title="1">if !comparable(ff.Type) </span><span class="cov8" title="1">{
                        q.errorf("%w: cannot sort by unorderable %q", ErrParam, name)
                        return q
                }</span>
                <span class="cov8" title="1">q.xorders = append(q.xorders, order{ff, asc})</span>
        }
        <span class="cov8" title="1">return q</span>
}

// Gather causes an Update or Delete operation to return the values of the
// affect records into l. For Update, the updated records are returned.
func (q *Query[T]) Gather(l *[]T) *Query[T] <span class="cov8" title="1">{
        if !q.checkErr() </span><span class="cov0" title="0">{
                return q
        }</span>
        <span class="cov8" title="1">if l == nil </span><span class="cov8" title="1">{
                q.errorf("%w: l must be non-nil", ErrParam)
                return q
        }</span>
        <span class="cov8" title="1">if q.gathers != nil </span><span class="cov8" title="1">{
                q.errorf("%w: can only have one Gather", ErrParam)
                return q
        }</span>
        <span class="cov8" title="1">q.gathers = l
        return q</span>
}

// GatherIDs causes an Update or Delete operation to return the primary keys of
// affected records into ids, which must be a pointer to a slice of T's
// primary key.
func (q *Query[T]) GatherIDs(ids any) *Query[T] <span class="cov8" title="1">{
        if !q.checkErr() </span><span class="cov0" title="0">{
                return q
        }</span>
        <span class="cov8" title="1">if ids == nil </span><span class="cov8" title="1">{
                q.errorf("%w: ids must be non-nil", ErrParam)
                return q
        }</span>
        <span class="cov8" title="1">rv := reflect.ValueOf(ids)
        t := rv.Type()
        if t.Kind() != reflect.Ptr || t.Elem().Kind() != reflect.Slice || t.Elem().Elem() != q.pkType </span><span class="cov8" title="1">{
                q.errorf("%w: ids must be pointer to slice of %v, not %T", ErrParam, q.pkType, ids)
                return q
        }</span>
        <span class="cov8" title="1">if q.gatherIDs.IsValid() </span><span class="cov8" title="1">{
                q.errorf("%w: can only have one GatherIDs", ErrParam)
                return q
        }</span>
        <span class="cov8" title="1">q.gatherIDs = rv
        return q</span>
}

func (q *Query[T]) gather(v T, rv reflect.Value) <span class="cov8" title="1">{
        if q.gathers != nil </span><span class="cov8" title="1">{
                *q.gathers = append(*q.gathers, v)
        }</span>
        <span class="cov8" title="1">if q.gatherIDs.IsValid() </span><span class="cov8" title="1">{
                ridv := rv.FieldByIndex(q.st.Current.Fields[0].structField.Index)
                l := q.gatherIDs.Elem()
                nl := reflect.Append(l, ridv)
                l.Set(nl)
        }</span>
}

// Err returns if an error is set on the query. Can happen for invalid filters.
// Finished queries return ErrFinished.
func (q *Query[T]) Err() error <span class="cov8" title="1">{
        q.checkErr()
        return q.err
}</span>

// Delete removes the selected records, returning how many were deleted.
//
// See Gather and GatherIDs for collecting the deleted records or IDs.
func (q *Query[T]) Delete() (deleted int, rerr error) <span class="cov8" title="1">{
        defer q.finish(&amp;rerr)
        q.checkNotNext()
        if !q.checkErr() </span><span class="cov0" title="0">{
                return 0, q.err
        }</span>

        <span class="cov8" title="1">n := 0
        err := q.foreachKey(true, true, func(bk []byte, ov T) error </span><span class="cov8" title="1">{
                n++
                rov := reflect.ValueOf(ov)
                q.gather(ov, rov)
                q.stats.Delete++
                return q.xtx.delete(q.exec.rb, q.st, bk, rov)
        }</span>)
        <span class="cov8" title="1">return n, err</span>
}

// Get returns the single selected record.
//
// ErrMultiple is returned if multiple records were selected.
// ErrAbsent is returned if no record was selected.
func (q *Query[T]) Get() (value T, rerr error) <span class="cov8" title="1">{
        defer q.finish(&amp;rerr)
        q.checkNotNext()
        if !q.checkErr() </span><span class="cov0" title="0">{
                var zero T
                return zero, q.err
        }</span>

        <span class="cov8" title="1">if _, v, err := q.nextKey(false, true); err != nil </span><span class="cov8" title="1">{
                return v, err
        }</span> else<span class="cov8" title="1"> if _, _, err := q.nextKey(false, false); err == nil </span><span class="cov8" title="1">{
                return v, ErrMultiple
        }</span> else<span class="cov8" title="1"> {
                return v, nil
        }</span>
}

// Count returns the number of selected records.
func (q *Query[T]) Count() (n int, rerr error) <span class="cov8" title="1">{
        defer q.finish(&amp;rerr)
        q.checkNotNext()
        if !q.checkErr() </span><span class="cov8" title="1">{
                return 0, q.err
        }</span>

        <span class="cov8" title="1">err := q.foreachKey(false, false, func(kb []byte, unused T) error </span><span class="cov8" title="1">{
                n++
                return nil
        }</span>)
        <span class="cov8" title="1">return n, err</span>
}

// List returns all selected records.
func (q *Query[T]) List() (list []T, rerr error) <span class="cov8" title="1">{
        defer q.finish(&amp;rerr)
        q.checkNotNext()
        if !q.checkErr() </span><span class="cov8" title="1">{
                return nil, q.err
        }</span>

        <span class="cov8" title="1">var l []T
        err := q.foreachKey(false, true, func(unused []byte, v T) error </span><span class="cov8" title="1">{
                l = append(l, v)
                return nil
        }</span>)
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return l, nil</span>
}

// UpdateNonzero updates all selected records with the non-zero fields from
// value, returning the number of records updated.
//
// Recall that false, 0, "" are all zero values. Use UpdateField or
// UpdateFields to set fields to zero their value.
//
// See Gather and GatherIDs for collecting the updated records or IDs.
//
// Keep in mind that updating on an embed/anonymous field looks at individual
// fields in the embedded field for non-zeroness, not at the embed field as a whole.
func (q *Query[T]) UpdateNonzero(value T) (updated int, rerr error) <span class="cov8" title="1">{
        defer q.finish(&amp;rerr)
        q.checkNotNext()
        if !q.checkErr() </span><span class="cov0" title="0">{
                return 0, q.err
        }</span>

        <span class="cov8" title="1">fields, values, err := gatherNonzeroFields(q.st.Current, reflect.ValueOf(value), false)
        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>
        <span class="cov8" title="1">sfl := make([]reflect.StructField, len(fields))
        for i, f := range fields </span><span class="cov8" title="1">{
                sfl[i] = f.structField
        }</span>
        <span class="cov8" title="1">return q.update(sfl, values)</span>
}

// UpdateField calls UpdateFields for fieldName and value.
func (q *Query[T]) UpdateField(fieldName string, value any) (updated int, rerr error) <span class="cov8" title="1">{
        return q.UpdateFields(map[string]any{fieldName: value})
}</span>

// UpdateFields updates all selected records, setting fields named by the map
// keys of fieldValues to the corresponding map value and returning the number
// of records updated.
//
// See Gather and GatherIDs for collecting the updated records or IDs.
//
// Entire embed fields can be updated, as well as their individual embedded
// fields.
func (q *Query[T]) UpdateFields(fieldValues map[string]any) (updated int, rerr error) <span class="cov8" title="1">{
        defer q.finish(&amp;rerr)
        q.checkNotNext()
        if !q.checkErr() </span><span class="cov0" title="0">{
                return 0, q.err
        }</span>

        <span class="cov8" title="1">if len(fieldValues) == 0 </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("%w: must update at least one field", ErrParam)
        }</span>

        <span class="cov8" title="1">fields := make([]reflect.StructField, 0, len(fieldValues))
        values := make([]reflect.Value, 0, len(fieldValues))
next:
        for name, value := range fieldValues </span><span class="cov8" title="1">{
                for i, f := range q.st.Current.Fields </span><span class="cov8" title="1">{
                        if f.Name != name </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if i == 0 </span><span class="cov8" title="1">{
                                return 0, fmt.Errorf("%w: cannot update primary key", ErrParam)
                        }</span>
                        <span class="cov8" title="1">rv, ok := q.prepareValue(f.Name, f.Type, f.structField, reflect.ValueOf(value))
                        if !ok </span><span class="cov8" title="1">{
                                return 0, q.err
                        }</span>
                        <span class="cov8" title="1">fields = append(fields, f.structField)
                        values = append(values, rv)
                        continue next</span>
                }
                <span class="cov8" title="1">for _, ef := range q.st.Current.embedFields </span><span class="cov8" title="1">{
                        if ef.Name != name </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">rv, ok := q.prepareValue(ef.Name, ef.Type, ef.structField, reflect.ValueOf(value))
                        if !ok </span><span class="cov0" title="0">{
                                return 0, q.err
                        }</span>
                        <span class="cov8" title="1">fields = append(fields, ef.structField)
                        values = append(values, rv)
                        continue next</span>
                }
                <span class="cov8" title="1">return 0, fmt.Errorf("%w: unknown field %q", ErrParam, name)</span>
        }
        <span class="cov8" title="1">return q.update(fields, values)</span>
}

func (q *Query[T]) update(fields []reflect.StructField, values []reflect.Value) (int, error) <span class="cov8" title="1">{
        n := 0
        ov := reflect.New(q.st.Type).Elem()
        err := q.foreachKey(true, true, func(bk []byte, v T) error </span><span class="cov8" title="1">{
                n++
                rv := reflect.ValueOf(&amp;v).Elem()
                ov.Set(rv)
                for i, sf := range fields </span><span class="cov8" title="1">{
                        frv := rv.FieldByIndex(sf.Index)
                        frv.Set(values[i])
                }</span>
                <span class="cov8" title="1">q.gather(v, rv)
                q.stats.Update++
                return q.xtx.update(q.exec.rb, q.st, rv, ov, bk)</span>
        })
        <span class="cov8" title="1">return n, err</span>
}

// IDs sets idsptr to the primary keys of selected records. Idptrs must be a
// slice of T's primary key type.
func (q *Query[T]) IDs(idsptr any) (rerr error) <span class="cov8" title="1">{
        defer q.finish(&amp;rerr)
        q.checkNotNext()
        if !q.checkErr() </span><span class="cov0" title="0">{
                return q.err
        }</span>

        <span class="cov8" title="1">if idsptr == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: idsptr must not be nil", ErrParam)
        }</span>
        <span class="cov8" title="1">rv := reflect.ValueOf(idsptr)
        if rv.Type().Kind() != reflect.Ptr || rv.Type().Elem().Kind() != reflect.Slice || rv.Type().Elem().Elem() != q.pkType </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: idsptr must be a ptr to slice of %v, not %T", ErrParam, q.pkType, idsptr)
        }</span>

        <span class="cov8" title="1">s := reflect.MakeSlice(rv.Type().Elem(), 0, 0)
        err := q.foreachID(false, func(pkv any) error </span><span class="cov8" title="1">{
                s = reflect.Append(s, reflect.ValueOf(pkv))
                return nil
        }</span>)
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">rv.Elem().Set(s)
        return nil</span>
}

// Next fetches the next record, moving the cursor forward.
//
// ErrAbsent is returned if no more records match.
//
// Automatically created transactions are read-only.
//
// Close must be called on a Query on which Next or NextID was called and that
// is not yet finished, i.e. has not yet returned an error (including
// ErrAbsent).
func (q *Query[T]) Next() (value T, rerr error) <span class="cov8" title="1">{
        // note: no q.finish preamble because caller iterates over result themselves.
        if !q.checkErr() </span><span class="cov0" title="0">{
                var zero T
                return zero, q.err
        }</span>

        <span class="cov8" title="1">q.nextOnly = true
        _, v, err := q.nextKey(false, true)
        if err == ErrAbsent </span><span class="cov8" title="1">{
                q.error(err)
        }</span>
        <span class="cov8" title="1">return v, err</span>
}

// NextID is like Next, but only fetches the primary key of the next matching
// record, storing it in idptr.
func (q *Query[T]) NextID(idptr any) (rerr error) <span class="cov8" title="1">{
        // note: no q.finish preamble because caller iterates over result themselves.
        if !q.checkErr() </span><span class="cov0" title="0">{
                return q.err
        }</span>

        <span class="cov8" title="1">q.nextOnly = true
        rpkv := reflect.ValueOf(idptr)
        if idptr == nil </span><span class="cov8" title="1">{
                q.errorf("%w: idptr must be non-nil", ErrParam)
                return q.err
        }</span>
        <span class="cov8" title="1">t := rpkv.Type()
        if t.Kind() != reflect.Ptr || t.Elem() != q.pkType </span><span class="cov8" title="1">{
                return fmt.Errorf("%w: value must be ptr to %v, not %v", ErrParam, q.pkType, t)
        }</span>
        <span class="cov8" title="1">err := q.nextID(false, rpkv.Elem())
        if err == ErrAbsent </span><span class="cov8" title="1">{
                q.error(err)
        }</span>
        <span class="cov8" title="1">return err</span>
}

// Exists returns whether any record was selected.
func (q *Query[T]) Exists() (exists bool, rerr error) <span class="cov8" title="1">{
        defer q.finish(&amp;rerr)
        q.checkNotNext()
        if !q.checkErr() </span><span class="cov0" title="0">{
                return false, q.err
        }</span>

        <span class="cov8" title="1">q.xlimit = 1
        _, _, err := q.nextKey(false, false)
        if err == ErrAbsent </span><span class="cov8" title="1">{
                return false, nil
        }</span>
        <span class="cov8" title="1">return err == nil, err</span>
}

// ForEach calls fn on each selected record.
func (q *Query[T]) ForEach(fn func(value T) error) (rerr error) <span class="cov8" title="1">{
        defer q.finish(&amp;rerr)
        q.checkNotNext()
        if !q.checkErr() </span><span class="cov0" title="0">{
                return q.err
        }</span>

        <span class="cov8" title="1">return q.foreachKey(false, true, func(bk []byte, v T) error </span><span class="cov8" title="1">{
                return fn(v)
        }</span>)
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package bstore

import (
        "bytes"
        "encoding/binary"
        "encoding/json"
        "fmt"
        "reflect"
        "sort"
        "strconv"
        "strings"
        "time"

        bolt "github.com/etcd-io/bbolt"
)

const (
        ondiskVersion1 = 1
)

// Register registers the Go types of each value in typeValues for use with the
// database. Each value must be a struct, not a pointer.
//
// Type definition versions (schema versions) are added to the database if they
// don't already exist or have changed. Existing type definitions are checked
// for compatibility. Unique indexes are created if they don't already exist.
// Creating a new unique index fails with ErrUnique on duplicate values.  If a
// nonzero constraint is added, all records are verified to be nonzero. If a zero
// value is found, ErrZero is returned.
//
// Register can be called multiple times, with different types. But types that
// reference each other must be registered in the same call to Registers.
func (db *DB) Register(typeValues ...any) error <span class="cov8" title="1">{
        // We will drop/create new indices as needed. For changed indices, we drop
        // and recreate. E.g. if an index becomes a unique index, or if a field in
        // an index changes.  These values map type and index name to their index.
        oindices := map[string]map[string]*index{} // Existing in previous typeVersion.
        nindices := map[string]map[string]*index{} // Existing in new typeVersion.

        otypeversions := map[string]*typeVersion{} // Replaced typeVersions.
        ntypeversions := map[string]*typeVersion{} // New typeversions, through new types or updated versions of existing types.
        registered := map[string]*storeType{}      // Registered in this call.

        return db.Write(func(tx *Tx) error </span><span class="cov8" title="1">{
                for _, t := range typeValues </span><span class="cov8" title="1">{
                        rt := reflect.TypeOf(t)
                        if rt.Kind() != reflect.Struct </span><span class="cov8" title="1">{
                                return fmt.Errorf("%w: type value %T is not a struct", ErrParam, t)
                        }</span>

                        <span class="cov8" title="1">tv, err := gatherTypeVersion(rt)
                        if err != nil </span><span class="cov8" title="1">{
                                return fmt.Errorf("%w: generating schema for type %q", err, rt.Name())
                        }</span>

                        // Ensure buckets exist.
                        <span class="cov8" title="1">tx.stats.Bucket.Get++
                        b := tx.btx.Bucket([]byte(tv.name))
                        var rb, tb *bolt.Bucket
                        if b == nil </span><span class="cov8" title="1">{
                                var err error
                                tx.stats.Bucket.Put++
                                b, err = tx.btx.CreateBucket([]byte(tv.name))
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("creating bucket for type %q: %w", tv.name, err)
                                }</span>
                                <span class="cov8" title="1">tx.stats.Bucket.Put++
                                rb, err = b.CreateBucket([]byte("records"))
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("creating records bucket for type %q: %w", tv.name, err)
                                }</span>
                                <span class="cov8" title="1">tx.stats.Bucket.Put++
                                tb, err = b.CreateBucket([]byte("types"))
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("creating types bucket for type %q: %w", tv.name, err)
                                }</span>
                        } else<span class="cov8" title="1"> {
                                rb, err = tx.recordsBucket(tv.name, tv.fillPercent)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov8" title="1">tb, err = tx.bucket(bucketKey{tv.name, "types"})
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }

                        <span class="cov8" title="1">st, ok := db.typeNames[tv.name]
                        if ok </span><span class="cov8" title="1">{
                                return fmt.Errorf("%w: type %q already registered", ErrParam, tv.name)
                        }</span>
                        <span class="cov8" title="1">st = storeType{
                                Name:     tv.name,
                                Type:     rt,
                                Versions: map[uint32]*typeVersion{},
                        }

                        // We read all type definitions.
                        err = tb.ForEach(func(bk, bv []byte) error </span><span class="cov8" title="1">{
                                // note: we don't track stats for types operations.

                                otv, err := parseSchema(bk, bv)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov8" title="1">if _, ok := st.Versions[otv.Version]; ok </span><span class="cov0" title="0">{
                                        return fmt.Errorf("%w: duplicate schema version %d", ErrStore, otv.Version)
                                }</span>
                                <span class="cov8" title="1">st.Versions[otv.Version] = otv
                                if st.Current == nil || otv.Version &gt; st.Current.Version </span><span class="cov8" title="1">{
                                        st.Current = otv
                                }</span>
                                <span class="cov8" title="1">return nil</span>
                        })
                        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        // Decide if we need to add a new typeVersion to the database. I.e. a new type schema.
                        <span class="cov8" title="1">if st.Current == nil || !st.Current.typeEqual(*tv) </span><span class="cov8" title="1">{
                                tv.Version = 1
                                if st.Current != nil </span><span class="cov8" title="1">{
                                        tv.Version = st.Current.Version + 1
                                }</span>
                                <span class="cov8" title="1">k, v, err := packSchema(tv)
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("internal error: packing schema for type %q", tv.name)
                                }</span>

                                // note: we don't track types bucket operations in stats.
                                <span class="cov8" title="1">if err := tb.Put(k, v); err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("storing new schema: %w", err)
                                }</span>

                                <span class="cov8" title="1">if st.Current != nil </span><span class="cov8" title="1">{
                                        // Copy current ReferencedBy, updated later and check for consistency.
                                        tv.ReferencedBy = map[string]struct{}{}
                                        for name := range st.Current.ReferencedBy </span><span class="cov8" title="1">{
                                                tv.ReferencedBy[name] = struct{}{}
                                        }</span>

                                        // Indices can change: between index and unique, or fields.
                                        // We recreate them for such changes.
                                        <span class="cov8" title="1">recreateIndices := map[string]struct{}{}
                                        if err := tx.checkTypes(st.Current, tv, recreateIndices); err != nil </span><span class="cov8" title="1">{
                                                return fmt.Errorf("checking compatibility of types: %w", err)
                                        }</span>
                                        <span class="cov8" title="1">for iname := range recreateIndices </span><span class="cov8" title="1">{
                                                ibname := fmt.Sprintf("index.%s", iname)
                                                tx.stats.Bucket.Delete++
                                                if err := b.DeleteBucket([]byte(ibname)); err != nil </span><span class="cov0" title="0">{
                                                        return fmt.Errorf("%w: deleting bucket %q for incompatible index that would be recreated: %v", ErrStore, ibname, err)
                                                }</span>
                                                <span class="cov8" title="1">delete(st.Current.Indices, iname)</span>
                                        }

                                        <span class="cov8" title="1">oindices[st.Name] = st.Current.Indices
                                        otypeversions[st.Name] = st.Current

                                        // If the current latest (old) primary key has "noauto", but
                                        // the new version does not, we will ensure the records
                                        // bucket sequence (that we use for autoincrement) is set to
                                        // the highest value stored so far.
                                        if st.Current.Noauto &amp;&amp; !tv.Noauto </span><span class="cov8" title="1">{
                                                db.stats.Records.Cursor++
                                                bk, _ := rb.Cursor().Last()
                                                if bk != nil </span><span class="cov8" title="1">{
                                                        rv := reflect.New(tv.Fields[0].structField.Type).Elem()
                                                        if err := parsePK(rv, bk); err != nil </span><span class="cov0" title="0">{
                                                                return fmt.Errorf("parsing pk of last record to update autoincrement sequence: %w", err)
                                                        }</span>
                                                        <span class="cov8" title="1">var seq uint64
                                                        switch tv.Fields[0].Type.Kind </span>{
                                                        case kindInt8, kindInt16, kindInt32, kindInt64, kindInt:<span class="cov8" title="1">
                                                                seq = uint64(rv.Int())</span>
                                                        case kindUint8, kindUint16, kindUint32, kindUint64, kindUint:<span class="cov0" title="0">
                                                                seq = rv.Uint()</span>
                                                        default:<span class="cov0" title="0">
                                                                return fmt.Errorf("internal error: noauto on non-int primary key: %v", err)</span>
                                                        }
                                                        <span class="cov8" title="1">if err := rb.SetSequence(seq); err != nil </span><span class="cov0" title="0">{
                                                                return fmt.Errorf("%w: updating autoincrement sequence after schema change: %s", ErrStore, err)
                                                        }</span>
                                                }
                                        }
                                }
                                <span class="cov8" title="1">nindices[st.Name] = tv.Indices
                                ntypeversions[st.Name] = tv</span>
                        } else<span class="cov8" title="1"> {
                                tv.Version = st.Current.Version
                                // Start out with the previous ReferencedBy. May be updated later.
                                tv.ReferencedBy = st.Current.ReferencedBy
                        }</span>

                        // Prepare types for parsing into the registered reflect.Type.
                        <span class="cov8" title="1">for _, otv := range st.Versions </span><span class="cov8" title="1">{
                                st.prepare(otv, rt)
                        }</span>

                        <span class="cov8" title="1">st.Current = tv
                        st.Versions[tv.Version] = tv
                        db.typeNames[st.Name] = st
                        db.types[st.Type] = st
                        registered[st.Name] = &amp;st</span>
                }

                // Check that referenced types exist, and make links in the referenced types.
                <span class="cov8" title="1">for _, st := range registered </span><span class="cov8" title="1">{
                        tv := st.Current
                        for name := range tv.references </span><span class="cov8" title="1">{
                                _, ok := registered[name]
                                if !ok </span><span class="cov8" title="1">{
                                        return fmt.Errorf("%w: type %q referenced by type %q not registered; you must register them in the same call to Open/Register", ErrType, name, tv.name)
                                }</span>
                        }

                        // Link fields that are referenced.
                        <span class="cov8" title="1">for _, f := range tv.Fields </span><span class="cov8" title="1">{
                                for _, ref := range f.References </span><span class="cov8" title="1">{
                                        rtv := db.typeNames[ref].Current
                                        k := f.Type.Kind
                                        refk := rtv.Fields[0].Type.Kind
                                        if k != refk </span><span class="cov8" title="1">{
                                                return fmt.Errorf("%w: %s.%s references %s.%s but fields have different types %s and %s", ErrType, tv.name, f.Name, rtv.name, rtv.Fields[0].Name, k, refk)
                                        }</span>
                                        // todo: should check if an index on this field exists, regardless of name. safes us an index.
                                        <span class="cov8" title="1">idx, ok := tv.Indices[f.Name+":"+ref]
                                        if !ok </span><span class="cov0" title="0">{
                                                return fmt.Errorf("internal error: missing index for ref")
                                        }</span>
                                        <span class="cov8" title="1">rtv.referencedBy = append(rtv.referencedBy, idx)</span>
                                }
                        }
                }

                // Ensure that for all registered storeTypes, their Current.ReferencedBy are up to
                // date by adding/removing. We mark those that need updating. We only have to check
                // ntypeversions: If a reference by a type changed, a new typeversion is created.
                // We cannot just recalculate the ReferencedBy, because the whole point is to
                // detect types that are missing in this Register.
                <span class="cov8" title="1">updateReferencedBy := map[string]struct{}{}
                for _, ntv := range ntypeversions </span><span class="cov8" title="1">{
                        otv := otypeversions[ntv.name] // Can be nil, on first register.

                        // Look for references that were added.
                        for name := range ntv.references </span><span class="cov8" title="1">{
                                if otv != nil </span><span class="cov8" title="1">{
                                        if _, ok := otv.references[name]; ok </span><span class="cov0" title="0">{
                                                // Reference was present in previous typeVersion, nothing to do.
                                                continue</span>
                                        }
                                }
                                <span class="cov8" title="1">if _, ok := registered[name].Current.ReferencedBy[ntv.name]; ok </span><span class="cov0" title="0">{
                                        return fmt.Errorf("%w: newly referencing type %q already present in %q", ErrStore, ntv.name, name)
                                }</span>
                                // note: we are updating the previous tv's ReferencedBy, not tidy but it is safe.
                                <span class="cov8" title="1">registered[name].Current.ReferencedBy[ntv.name] = struct{}{}
                                updateReferencedBy[name] = struct{}{}</span>
                        }
                        <span class="cov8" title="1">if otv == nil </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        // Look for references that were removed.
                        // We cannot use summary field otv.references, it isn't set, we go to the source,
                        // otv.Fields[].References.
                        <span class="cov8" title="1">orefs := map[string]struct{}{}
                        for _, f := range otv.Fields </span><span class="cov8" title="1">{
                                for _, name := range f.References </span><span class="cov8" title="1">{
                                        orefs[name] = struct{}{}
                                }</span>
                        }
                        <span class="cov8" title="1">for name := range orefs </span><span class="cov8" title="1">{
                                if _, ok := ntv.references[name]; ok </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">if _, ok := registered[name].Current.ReferencedBy[ntv.name]; !ok </span><span class="cov0" title="0">{
                                        return fmt.Errorf("%w: previously referenced type %q not present in %q", ErrStore, ntv.name, name)
                                }</span>
                                // note: we are updating the previous tv's ReferencedBy, not tidy but it is safe.
                                <span class="cov8" title="1">delete(registered[name].Current.ReferencedBy, ntv.name)
                                updateReferencedBy[name] = struct{}{}</span>
                        }
                }

                // Update/create new typeversions based on updated ReferencedBy.
                <span class="cov8" title="1">for name := range updateReferencedBy </span><span class="cov8" title="1">{
                        // If we already created a new typeVersion in this Register, we can just update it
                        // again. Otherwise we create a new typeVersion, but none of the other checks
                        // (eg index) because those weren't changed (or we would have a new typeversion already).
                        // We don't update ntypeversions/otypeversions, the changed ReferencedBy aren't relevant below this point.
                        ntvp, ok := ntypeversions[name]
                        if !ok </span><span class="cov8" title="1">{
                                st := registered[name]
                                ntv := *st.Current
                                ntv.Version++
                                st.Versions[ntv.Version] = &amp;ntv
                                st.Current = &amp;ntv
                                db.types[st.Type] = *st
                                db.typeNames[st.Name] = *st
                                ntvp = &amp;ntv
                        }</span>

                        <span class="cov8" title="1">k, v, err := packSchema(ntvp)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("internal error: packing schema for type %q", ntvp.name)
                        }</span>
                        <span class="cov8" title="1">tb, err := tx.bucket(bucketKey{ntvp.name, "types"})
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        // note: we don't track types bucket operations in stats.
                        <span class="cov8" title="1">if err := tb.Put(k, v); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("storing new schema: %w", err)
                        }</span>
                }

                // Now that all ReferencedBy are up to date, verify that all referenced types were
                // registered in this call.
                // The whole point of this exercise is to catch a Register of a type that is
                // referenced, but whose type isn't registered. If we would allow registering just this
                // referenced type, users can delete data that is still referenced by the
                // not-registered registering type.
                <span class="cov8" title="1">for _, st := range registered </span><span class="cov8" title="1">{
                        for name := range st.Current.ReferencedBy </span><span class="cov8" title="1">{
                                if _, ok := registered[name]; !ok </span><span class="cov8" title="1">{
                                        return fmt.Errorf("%w: must register %q that references %q in same Open/Register call", ErrType, name, st.Name)
                                }</span>
                        }
                }

                // Check that any new nonzero constraints are correct.
                <span class="cov8" title="1">for _, tv := range ntypeversions </span><span class="cov8" title="1">{
                        otv, ok := otypeversions[tv.name]
                        if !ok </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">st := db.typeNames[tv.name]
                        if err := tx.checkNonzero(st, tv, otv.Fields, tv.Fields); err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                }

                // Drop old/modified indices.
                <span class="cov8" title="1">for name, tindices := range oindices </span><span class="cov8" title="1">{
                        for iname, idx := range tindices </span><span class="cov8" title="1">{
                                var drop bool
                                if _, ok := nindices[name]; !ok </span><span class="cov0" title="0">{
                                        drop = true
                                }</span> else<span class="cov8" title="1"> if _, ok := nindices[name][iname]; !ok </span><span class="cov8" title="1">{
                                        drop = true
                                }</span> else<span class="cov8" title="1"> if !idx.typeEqual(nindices[name][iname]) </span><span class="cov8" title="1">{
                                        drop = true
                                }</span>
                                <span class="cov8" title="1">if !drop </span><span class="cov8" title="1">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">b, err := tx.typeBucket(name)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov8" title="1">ibname := fmt.Sprintf("index.%s", iname)
                                tx.stats.Bucket.Delete++
                                if err := b.DeleteBucket([]byte(ibname)); err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("%w: deleting bucket %q for old/modified index: %v", ErrStore, ibname, err)
                                }</span>
                        }
                }

                // Create new/modified indices.
                <span class="cov8" title="1">for name, tindices := range nindices </span><span class="cov8" title="1">{
                        // First prepare, checking if we should create this index and preparing the index bucket if so.
                        var idxs []*index
                        var ibs []*bolt.Bucket
                        for iname, idx := range tindices </span><span class="cov8" title="1">{
                                var create bool
                                if _, ok := oindices[name]; !ok </span><span class="cov8" title="1">{
                                        create = true
                                }</span> else<span class="cov8" title="1"> if _, ok := oindices[name][iname]; !ok </span><span class="cov8" title="1">{
                                        create = true
                                }</span> else<span class="cov8" title="1"> if !idx.typeEqual(oindices[name][iname]) </span><span class="cov8" title="1">{
                                        create = true
                                }</span>
                                <span class="cov8" title="1">if !create </span><span class="cov8" title="1">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">b, err := tx.typeBucket(name)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                                <span class="cov8" title="1">ibname := []byte(fmt.Sprintf("index.%s", iname))
                                tx.stats.Bucket.Put++
                                ib, err := b.CreateBucket(ibname)
                                if err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("%w: creating bucket %q for old/modified index: %v", ErrStore, ibname, err)
                                }</span>
                                <span class="cov8" title="1">idxs = append(idxs, idx)
                                ibs = append(ibs, ib)</span>
                        }

                        <span class="cov8" title="1">if len(idxs) == 0 </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">st := db.typeNames[name]
                        rb, err := tx.recordsBucket(name, st.Current.fillPercent)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        // We first generate all keys. Then sort them and insert them.
                        // Random inserts can be slow in boltdb. We can efficiently verify
                        // that the values are indeed unique by keeping track of the non-PK
                        // prefix length and checking the key inserted previously.
                        <span class="cov8" title="1">type key struct {
                                buf []byte
                                pre uint16
                        }
                        ibkeys := make([][]key, len(idxs))

                        err = rb.ForEach(func(bk, bv []byte) error </span><span class="cov8" title="1">{
                                tx.stats.Records.Cursor++

                                rv := reflect.New(st.Type).Elem()
                                if err := st.parse(rv, bv); err != nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("parsing record for index for %s: %w", name, err)
                                }</span>

                                <span class="cov8" title="1">for i, idx := range idxs </span><span class="cov8" title="1">{
                                        prek, ik, err := idx.packKey(rv, bk)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return fmt.Errorf("creating key for %s.%s: %w", name, idx.Name, err)
                                        }</span>
                                        <span class="cov8" title="1">ibkeys[i] = append(ibkeys[i], key{ik, uint16(len(prek))})</span>
                                }
                                <span class="cov8" title="1">return nil</span>
                        })
                        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("preparing index keys for type %q: %w", name, err)
                        }</span>

                        <span class="cov8" title="1">insertKeys := func(idx *index, ib *bolt.Bucket, keys []key) error </span><span class="cov8" title="1">{
                                ib.FillPercent = 1
                                defer func() </span><span class="cov8" title="1">{
                                        ib.FillPercent = 0.5
                                }</span>()
                                <span class="cov8" title="1">for i, k := range keys </span><span class="cov8" title="1">{
                                        if idx.Unique &amp;&amp; i &gt; 0 </span><span class="cov8" title="1">{
                                                prev := keys[i-1]
                                                if bytes.Equal(prev.buf[:prev.pre], k.buf[:k.pre]) </span><span class="cov8" title="1">{
                                                        // Do quite a bit of work to make a helpful error message.
                                                        a := reflect.New(reflect.TypeOf(idx.tv.Fields[0].Type.zero(nil))).Elem()
                                                        b := reflect.New(reflect.TypeOf(idx.tv.Fields[0].Type.zero(nil))).Elem()
                                                        parsePK(a, prev.buf[prev.pre:]) // Ignore error, nothing to do.
                                                        parsePK(b, k.buf[k.pre:])       // Ignore error, nothing to do.
                                                        var dup []any
                                                        _, values, _ := idx.parseKey(k.buf, true)
                                                        for i := range values </span><span class="cov8" title="1">{
                                                                x := reflect.New(reflect.TypeOf(idx.Fields[i].Type.zero(nil))).Elem()
                                                                parsePK(x, values[i]) // Ignore error, nothing to do.
                                                                dup = append(dup, x.Interface())
                                                        }</span>
                                                        <span class="cov8" title="1">return fmt.Errorf("%w: duplicate value %v on index %s.%s for ids %v and %v", ErrUnique, dup, name, idx.Name, a.Interface(), b.Interface())</span>
                                                }
                                        }
                                        <span class="cov8" title="1">tx.stats.Index.Put++
                                        if err := ib.Put(k.buf, []byte{}); err != nil </span><span class="cov0" title="0">{
                                                return fmt.Errorf("inserting index key into %s.%s: %w", name, idxs[i].Name, err)
                                        }</span>
                                }
                                <span class="cov8" title="1">return nil</span>
                        }

                        // Now do all sorts + inserts.
                        <span class="cov8" title="1">for i, ib := range ibs </span><span class="cov8" title="1">{
                                idx := idxs[i]
                                keys := ibkeys[i]
                                sort.Slice(keys, func(i, j int) bool </span><span class="cov8" title="1">{
                                        return bytes.Compare(keys[i].buf, keys[j].buf) &lt; 0
                                }</span>)
                                <span class="cov8" title="1">if err := insertKeys(idx, ib, keys); err != nil </span><span class="cov8" title="1">{
                                        return err
                                }</span>
                                <span class="cov8" title="1">ibkeys[i] = nil</span>
                        }
                }
                <span class="cov8" title="1">return nil</span>
        })
}

// parseSchema parses a schema from the type bucket into a typeversion.
func parseSchema(bk, bv []byte) (*typeVersion, error) <span class="cov8" title="1">{
        if len(bk) != 4 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%w: version: got %d bytes, need 4", ErrStore, len(bk))
        }</span>
        <span class="cov8" title="1">version := binary.BigEndian.Uint32(bk)

        // We store these in self-describing json, to prevent complications if we want to adjust our formats in the future.

        var tv typeVersion
        if err := json.Unmarshal(bv, &amp;tv); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%w: unmarshal schema: %v", ErrStore, err)
        }</span>
        <span class="cov8" title="1">if tv.Version != version </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%w: version in schema %d does not match key %d", ErrStore, tv.Version, version)
        }</span>
        <span class="cov8" title="1">if tv.OndiskVersion != ondiskVersion1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("internal error: OndiskVersion %d not supported", tv.OndiskVersion)
        }</span>

        <span class="cov8" title="1">return &amp;tv, nil</span>
}

// packSchema returns a key and value to store in the types bucket.
func packSchema(tv *typeVersion) ([]byte, []byte, error) <span class="cov8" title="1">{
        if tv.OndiskVersion != ondiskVersion1 </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("internal error: invalid OndiskVersion %d", tv.OndiskVersion)
        }</span>
        <span class="cov8" title="1">v, err := json.Marshal(tv)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("internal error: marshal schema: %v", err)
        }</span>
        <span class="cov8" title="1">k := binary.BigEndian.AppendUint32(nil, tv.Version)
        return k, v, nil</span>
}

func gatherTypeVersion(t reflect.Type) (*typeVersion, error) <span class="cov8" title="1">{
        if t.NumField() == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("%w: type must have at least one field", ErrType)
        }</span>
        <span class="cov8" title="1">tname, err := typeName(t)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">tv := &amp;typeVersion{
                Version:       0,              // Set by caller.
                OndiskVersion: ondiskVersion1, // Current on-disk format.
                ReferencedBy:  map[string]struct{}{},
                name:          tname,
                fillPercent:   0.5,
        }
        tv.Fields, tv.embedFields, err = gatherTypeFields(t, true, true, false)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">tags, err := newStoreTags(t.Field(0).Tag.Get("bstore"), true)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">tv.Noauto = tags.Has("noauto")
        if tv.Noauto </span><span class="cov8" title="1">{
                switch tv.Fields[0].Type.Kind </span>{
                case kindInt, kindInt8, kindInt16, kindInt32, kindInt64, kindUint, kindUint8, kindUint16, kindUint32, kindUint64:<span class="cov8" title="1"></span>
                default:<span class="cov8" title="1">
                        return nil, fmt.Errorf("%w: cannot have noauto on non-integer primary key field", ErrType)</span>
                }
        }

        // Find indices.
        <span class="cov8" title="1">tv.Indices = map[string]*index{}

        addIndex := func(unique bool, iname string, fields ...*field) error </span><span class="cov8" title="1">{
                idx := tv.Indices[iname]
                if idx != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("%w: duplicate unique/index %q", ErrType, iname)
                }</span>
                <span class="cov8" title="1">idx = &amp;index{unique, iname, nil, tv}
                tv.Indices[iname] = idx
                for _, f := range fields </span><span class="cov8" title="1">{
                        // todo: can we have a unique index on bytes? seems like this should be possible to have max 1 []byte in an index key, only to be used for unique get plans.
                        if f.Type.Ptr </span><span class="cov8" title="1">{
                                return fmt.Errorf("%w: cannot have index/unique on ptr field %s.%s", ErrType, tname, f.Name)
                        }</span>
                        <span class="cov8" title="1">switch f.Type.Kind </span>{
                        case kindBool, kindInt8, kindInt16, kindInt32, kindInt64, kindInt, kindUint8, kindUint16, kindUint32, kindUint64, kindUint, kindString, kindTime:<span class="cov8" title="1"></span>
                        default:<span class="cov8" title="1">
                                return fmt.Errorf("%w: cannot use type %v in field %q as index/unique", ErrType, f.Type.Kind, f.Name)</span>
                        }

                        <span class="cov8" title="1">if f.indices == nil </span><span class="cov8" title="1">{
                                f.indices = map[string]*index{}
                        }</span>
                        <span class="cov8" title="1">f.indices[iname] = idx
                        idx.Fields = append(idx.Fields, *f)</span>
                }
                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov8" title="1">fields := map[string]*field{}
        for i, f := range tv.Fields </span><span class="cov8" title="1">{
                fields[f.Name] = &amp;tv.Fields[i]
        }</span>

        <span class="cov8" title="1">addNamedIndex := func(unique bool, tag string, f *field) error </span><span class="cov8" title="1">{
                t := strings.Split(tag, " ")
                if len(t) &gt; 2 </span><span class="cov8" title="1">{
                        return fmt.Errorf("%w: invalid unique/index, too many tokens in %q", ErrType, tag)
                }</span>
                <span class="cov8" title="1">iname := t[0]
                if len(t) == 2 </span><span class="cov8" title="1">{
                        iname = t[1]
                }</span>

                <span class="cov8" title="1">names := strings.Split(t[0], "+")
                if names[0] != f.Name </span><span class="cov8" title="1">{
                        return fmt.Errorf("%w: invalid unique/index %q, first field must be same as struct field %q", ErrType, iname, f.Name)
                }</span>
                <span class="cov8" title="1">seen := map[string]struct{}{}
                var ifields []*field
                for _, fname := range names </span><span class="cov8" title="1">{
                        if _, ok := seen[fname]; ok </span><span class="cov8" title="1">{
                                return fmt.Errorf("%w: duplicate field %q in unique/index %q", ErrType, fname, iname)
                        }</span>
                        <span class="cov8" title="1">seen[fname] = struct{}{}
                        xf := fields[fname]
                        if xf == nil </span><span class="cov8" title="1">{
                                return fmt.Errorf("%w: unknown field %q in unique/index %q", ErrType, fname, iname)
                        }</span>
                        <span class="cov8" title="1">ifields = append(ifields, xf)</span>
                }
                <span class="cov8" title="1">return addIndex(unique, iname, ifields...)</span>
        }

        <span class="cov8" title="1">for i := range tv.Fields </span><span class="cov8" title="1">{
                f := &amp;tv.Fields[i]
                rft := t.FieldByIndex(f.structField.Index)
                tags, err := newStoreTags(rft.Tag.Get("bstore"), i == 0)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if tags.Has("unique") </span><span class="cov8" title="1">{
                        if err := addIndex(true, f.Name, f); err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                }
                <span class="cov8" title="1">if tags.Has("index") </span><span class="cov8" title="1">{
                        if err := addIndex(false, f.Name, f); err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                }
                <span class="cov8" title="1">for _, name := range tags.List("unique") </span><span class="cov8" title="1">{
                        if err := addNamedIndex(true, name, f); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }
                <span class="cov8" title="1">for _, name := range tags.List("index") </span><span class="cov8" title="1">{
                        if err := addNamedIndex(false, name, f); err != nil </span><span class="cov8" title="1">{
                                return nil, err
                        }</span>
                }
        }

        // Gather references. Add indices if they don't already exist.
        <span class="cov8" title="1">tv.references = map[string]struct{}{}
        for i := range tv.Fields </span><span class="cov8" title="1">{
                f := &amp;tv.Fields[i]
                refseen := map[string]struct{}{}
                tags, err := newStoreTags(f.structField.Tag.Get("bstore"), i == 0)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">for _, name := range tags.List("ref") </span><span class="cov8" title="1">{
                        if _, ok := refseen[name]; ok </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("%w: duplicate references %q in field %q", ErrType, name, f.Name)
                        }</span>
                        <span class="cov8" title="1">refseen[name] = struct{}{}
                        tv.references[name] = struct{}{}

                        iname := f.Name + ":" + name
                        if idx, ok := tv.Indices[iname]; ok </span><span class="cov8" title="1">{
                                if len(idx.Fields) != 1 || idx.Fields[0].Name != f.Name </span><span class="cov8" title="1">{
                                        return nil, fmt.Errorf("%w: reference requires an index, but another index with name %q for the field already exists", ErrType, iname)
                                }</span>
                        } else<span class="cov8" title="1"> {
                                if err := addIndex(false, iname, f); err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return tv, nil</span>
}

// gatherTypeFields gathers fields for a struct. If needFirst is true, the first
// field must not be ignored and be a valid primary key field (eg no pointer).
// topLevel must be true only for the top-level struct fields, not for fields of
// deeper levels. Deeper levels cannot have index/unique constraints.
func gatherTypeFields(t reflect.Type, needFirst, topLevel, inMap bool) ([]field, []embed, error) <span class="cov8" title="1">{
        var fields []field
        var embedFields []embed

        names := map[string]struct{}{}
        for i, sf := range reflect.VisibleFields(t) </span><span class="cov8" title="1">{
                tags, err := newStoreTags(sf.Tag.Get("bstore"), i == 0 &amp;&amp; needFirst &amp;&amp; topLevel)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, nil, err
                }</span>
                <span class="cov8" title="1">nonzero := tags.Has("nonzero")
                if i == 0 &amp;&amp; needFirst </span><span class="cov8" title="1">{
                        if !sf.IsExported() </span><span class="cov8" title="1">{
                                return nil, nil, fmt.Errorf("%w: first field is primary key and must be exported", ErrType)
                        }</span>
                        <span class="cov8" title="1">if sf.Anonymous </span><span class="cov8" title="1">{
                                // todo: We don't allow this now because the code often reads tv.Fields[0] to get the
                                // PK field. We could allow it, but it could confuse users, thinking the entire
                                // struct would become a PK.
                                return nil, nil, fmt.Errorf("%w: first field cannot be an embed/anonymous field", ErrType)
                        }</span>
                        <span class="cov8" title="1">if nonzero </span><span class="cov8" title="1">{
                                return nil, nil, fmt.Errorf("%w: superfluous nonzero tag on primary key", ErrType)
                        }</span>
                        <span class="cov8" title="1">if err := checkKeyType(sf.Type); err != nil </span><span class="cov8" title="1">{
                                return nil, nil, err
                        }</span>
                }
                <span class="cov8" title="1">if nonzero &amp;&amp; sf.Anonymous </span><span class="cov8" title="1">{
                        return nil, nil, fmt.Errorf("%w: cannot have nonzero on embed/anonymous field %q", ErrType, sf.Name)
                }</span>
                <span class="cov8" title="1">if tags.Has("-") &amp;&amp; sf.Anonymous </span><span class="cov8" title="1">{
                        return nil, nil, fmt.Errorf(`%w: cannot have "-" on embed/anonymous field %q`, ErrType, sf.Name)
                }</span>
                <span class="cov8" title="1">if !sf.IsExported() || tags.Has("-") </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if !topLevel &amp;&amp; (tags.Has("unique") || tags.Has("index")) </span><span class="cov8" title="1">{
                        return nil, nil, fmt.Errorf("%w: %q", errNestedIndex, sf.Name)
                }</span>

                <span class="cov8" title="1">name, err := tags.Get("name")
                if err != nil </span><span class="cov8" title="1">{
                        return nil, nil, err
                }</span> else<span class="cov8" title="1"> if name == "" </span><span class="cov8" title="1">{
                        name = sf.Name
                }</span>
                <span class="cov8" title="1">if _, ok := names[name]; ok </span><span class="cov8" title="1">{
                        return nil, nil, fmt.Errorf("%w: duplicate field %q", ErrType, name)
                }</span>
                <span class="cov8" title="1">names[name] = struct{}{}

                ft, err := gatherFieldType(sf.Type, inMap)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, nil, fmt.Errorf("field %q: %w", sf.Name, err)
                }</span>

                // Parse a default value.
                <span class="cov8" title="1">var def reflect.Value
                defstr, err := tags.Get("default")
                if err != nil </span><span class="cov8" title="1">{
                        return nil, nil, fmt.Errorf("field %q: %w", sf.Name, err)
                }</span> else<span class="cov8" title="1"> if defstr != "" </span><span class="cov8" title="1">{
                        if inMap </span><span class="cov8" title="1">{
                                return nil, nil, fmt.Errorf("%w: cannot have default value inside a map value", ErrType)
                        }</span>
                        <span class="cov8" title="1">var defv any
                        convert := true
                        switch ft.Kind </span>{
                        case kindBool:<span class="cov8" title="1">
                                convert = false
                                switch defstr </span>{
                                case "true":<span class="cov8" title="1">
                                        defv = true</span>
                                case "false":<span class="cov8" title="1">
                                        defv = false</span>
                                default:<span class="cov0" title="0">
                                        err = fmt.Errorf("%w: bad bool value %q for %s.%s", ErrType, defstr, t.Name(), sf.Name)</span>
                                }
                        case kindInt, kindInt32:<span class="cov8" title="1">
                                defv, err = strconv.ParseInt(defstr, 0, 32)</span>
                        case kindInt8:<span class="cov8" title="1">
                                defv, err = strconv.ParseInt(defstr, 0, 8)</span>
                        case kindInt16:<span class="cov8" title="1">
                                defv, err = strconv.ParseInt(defstr, 0, 16)</span>
                        case kindInt64:<span class="cov8" title="1">
                                defv, err = strconv.ParseInt(defstr, 0, 64)</span>
                        case kindUint, kindUint32:<span class="cov8" title="1">
                                defv, err = strconv.ParseUint(defstr, 0, 32)</span>
                        case kindUint8:<span class="cov8" title="1">
                                defv, err = strconv.ParseUint(defstr, 0, 8)</span>
                        case kindUint16:<span class="cov8" title="1">
                                defv, err = strconv.ParseUint(defstr, 0, 16)</span>
                        case kindUint64:<span class="cov8" title="1">
                                defv, err = strconv.ParseUint(defstr, 0, 64)</span>
                        case kindFloat32:<span class="cov8" title="1">
                                defv, err = strconv.ParseFloat(defstr, 32)</span>
                        case kindFloat64:<span class="cov8" title="1">
                                defv, err = strconv.ParseFloat(defstr, 64)</span>
                        case kindString:<span class="cov8" title="1">
                                convert = false
                                defv = defstr</span>
                        case kindTime:<span class="cov8" title="1">
                                convert = false
                                if defstr == "now" </span><span class="cov8" title="1">{
                                        defv = zerotime // Sentinel value recognized during evaluation.
                                }</span> else<span class="cov8" title="1"> {
                                        defv, err = time.Parse(time.RFC3339, defstr)
                                }</span>
                        default:<span class="cov8" title="1">
                                return nil, nil, fmt.Errorf("%w: default not supported for type %v", ErrType, ft.Kind)</span>
                        }
                        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                                return nil, nil, fmt.Errorf("%w: bad default value %q for %s %s.%s", ErrType, defstr, ft.Kind, t.Name(), sf.Name)
                        }</span>
                        <span class="cov8" title="1">deft := sf.Type
                        if ft.Ptr </span><span class="cov8" title="1">{
                                deft = sf.Type.Elem()
                        }</span>
                        <span class="cov8" title="1">def = reflect.ValueOf(defv)
                        if convert </span><span class="cov8" title="1">{
                                def = def.Convert(deft)
                        }</span>
                }

                <span class="cov8" title="1">if sf.Anonymous </span><span class="cov8" title="1">{
                        e := embed{name, ft, sf}
                        embedFields = append(embedFields, e)
                }</span> else<span class="cov8" title="1"> {
                        f := field{name, ft, nonzero, tags.List("ref"), defstr, def, sf, nil}
                        fields = append(fields, f)
                }</span>
        }
        <span class="cov8" title="1">return fields, embedFields, nil</span>
}

// checkKeyType returns an error if the type is not valid for use as primary key.
// similar to storeType.keyValue
func checkKeyType(t reflect.Type) error <span class="cov8" title="1">{
        k, err := typeKind(t)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">switch k </span>{
        case kindBytes, kindString, kindBool, kindInt, kindInt8, kindInt16, kindInt32, kindInt64, kindUint, kindUint8, kindUint16, kindUint32, kindUint64:<span class="cov8" title="1">
                return nil</span>
        }
        <span class="cov8" title="1">return fmt.Errorf("%w: type %v not valid for primary key", ErrType, t)</span>
}

func gatherFieldType(t reflect.Type, inMap bool) (fieldType, error) <span class="cov8" title="1">{
        ft := fieldType{}
        if t.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                t = t.Elem()
                ft.Ptr = true
        }</span>
        <span class="cov8" title="1">k, err := typeKind(t)
        if err != nil </span><span class="cov8" title="1">{
                return fieldType{}, err
        }</span>
        <span class="cov8" title="1">ft.Kind = k
        switch ft.Kind </span>{
        case kindSlice:<span class="cov8" title="1">
                l, err := gatherFieldType(t.Elem(), inMap)
                if err != nil </span><span class="cov8" title="1">{
                        return ft, fmt.Errorf("list: %w", err)
                }</span>
                <span class="cov8" title="1">ft.List = &amp;l</span>
        case kindMap:<span class="cov8" title="1">
                kft, err := gatherFieldType(t.Key(), true)
                if err != nil </span><span class="cov0" title="0">{
                        return ft, fmt.Errorf("map key: %w", err)
                }</span>
                <span class="cov8" title="1">if kft.Ptr </span><span class="cov8" title="1">{
                        return ft, fmt.Errorf("%w: map key with pointer type not supported", ErrType)
                }</span>
                <span class="cov8" title="1">vft, err := gatherFieldType(t.Elem(), true)
                if err != nil </span><span class="cov8" title="1">{
                        return ft, fmt.Errorf("map value: %w", err)
                }</span>
                <span class="cov8" title="1">ft.MapKey = &amp;kft
                ft.MapValue = &amp;vft</span>
        case kindStruct:<span class="cov8" title="1">
                // note: we have no reason to gather embed field beyond top-level
                fields, _, err := gatherTypeFields(t, false, false, inMap)
                if err != nil </span><span class="cov8" title="1">{
                        return fieldType{}, fmt.Errorf("struct: %w", err)
                }</span>
                <span class="cov8" title="1">ft.Fields = fields</span>
        }
        <span class="cov8" title="1">return ft, nil</span>
}

// prepare tv for storing type t into it.
// We have to look at later typeVersions that may have removed a field. If so,
// we will not set it on t but leave it at its default value.
func (st storeType) prepare(tv *typeVersion, t reflect.Type) <span class="cov8" title="1">{
        var l []*typeVersion
        for _, tv := range st.Versions </span><span class="cov8" title="1">{
                l = append(l, tv)
        }</span>
        <span class="cov8" title="1">sort.Slice(l, func(i, j int) bool </span><span class="cov8" title="1">{
                return l[i].Version &lt; l[j].Version
        }</span>)
        <span class="cov8" title="1">var later [][]field
        for _, tv := range l </span><span class="cov8" title="1">{
                later = append(later, tv.Fields)
        }</span>
        <span class="cov8" title="1">for i, tv := range l </span><span class="cov8" title="1">{
                tv.prepare(t, later[i+1:])
        }</span>
}

// prepare for use with parse.
func (tv typeVersion) prepare(t reflect.Type, later [][]field) <span class="cov8" title="1">{
        for i, f := range tv.Fields </span><span class="cov8" title="1">{
                nlater, skip := lookupLater(f.Name, later)
                if skip </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">tv.Fields[i].prepare(t, nlater)</span>
        }
}

func lookupLater(name string, later [][]field) ([][]field, bool) <span class="cov8" title="1">{
        // If a later typeVersion did not have this field, we will not parse it into the
        // latest reflect type. This is old data that was discarded with a typeVersion
        // change.
        var nlater [][]field
tv:
        for _, newerFields := range later </span><span class="cov8" title="1">{
                for _, nf := range newerFields </span><span class="cov8" title="1">{
                        if nf.Name == name </span><span class="cov8" title="1">{
                                nlater = append(nlater, nf.Type.Fields)
                                continue tv</span>
                        }
                }
                <span class="cov8" title="1">return nil, true</span>
        }
        <span class="cov8" title="1">return nlater, false</span>
}

func (f *field) prepare(t reflect.Type, later [][]field) <span class="cov8" title="1">{
        sf, ok := t.FieldByName(f.Name)
        if !ok </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">f.structField = sf
        f.Type.prepare(f.structField.Type, later)</span>
}

func (ft fieldType) prepare(t reflect.Type, later [][]field) <span class="cov8" title="1">{
        if t.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                t = t.Elem()
        }</span>
        <span class="cov8" title="1">for i, f := range ft.Fields </span><span class="cov8" title="1">{
                nlater, skip := lookupLater(f.Name, later)
                if skip </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">ft.Fields[i].prepare(t, nlater)</span>
        }
        <span class="cov8" title="1">if ft.MapKey != nil </span><span class="cov8" title="1">{
                ft.MapKey.prepare(t.Key(), later)
                ft.MapValue.prepare(t.Elem(), later)
        }</span>
        <span class="cov8" title="1">if ft.List != nil </span><span class="cov8" title="1">{
                ft.List.prepare(t.Elem(), later)
        }</span>
}

// typeEqual compares two typeVersions, typically the current for a
// storeType and a potential new typeVersion for a type that is being
// registered.
// If a field changes (add/remove/modify, including struct tag), a type is no
// longer equal.
// Does not take fields Version or Name into account.
func (tv typeVersion) typeEqual(ntv typeVersion) bool <span class="cov8" title="1">{
        if tv.OndiskVersion != ntv.OndiskVersion </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if tv.Noauto != ntv.Noauto </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if len(tv.Fields) != len(ntv.Fields) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">for i, f := range tv.Fields </span><span class="cov8" title="1">{
                if !f.typeEqual(ntv.Fields[i]) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        // note: embedFields are not relevant for equality, they are just a convenient way to set multiple fields.

        <span class="cov8" title="1">if len(tv.Indices) != len(ntv.Indices) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">for name, idx := range tv.Indices </span><span class="cov8" title="1">{
                if nidx, ok := ntv.Indices[name]; !ok || !idx.typeEqual(nidx) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

func (f field) typeEqual(nf field) bool <span class="cov8" title="1">{
        if f.Name != nf.Name || !f.Type.typeEqual(nf.Type) || f.Nonzero != nf.Nonzero || f.Default != nf.Default </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if len(f.References) != len(nf.References) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">for i, s := range f.References </span><span class="cov8" title="1">{
                if s != nf.References[i] </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

func (ft fieldType) typeEqual(nft fieldType) bool <span class="cov8" title="1">{
        if ft.Ptr != nft.Ptr || ft.Kind != nft.Kind </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if len(ft.Fields) != len(nft.Fields) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">for i, f := range ft.Fields </span><span class="cov8" title="1">{
                if !f.typeEqual(nft.Fields[i]) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">if ft.MapKey != nil &amp;&amp; (!ft.MapKey.typeEqual(*nft.MapKey) || !ft.MapValue.typeEqual(*nft.MapValue)) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if ft.List != nil &amp;&amp; !ft.List.typeEqual(*nft.List) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}

func (idx *index) typeEqual(nidx *index) bool <span class="cov8" title="1">{
        if idx.Unique != nidx.Unique || idx.Name != nidx.Name </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">if len(idx.Fields) != len(nidx.Fields) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">for i, f := range idx.Fields </span><span class="cov8" title="1">{
                if !f.typeEqual(nidx.Fields[i]) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// checkTypes checks if typeVersions otv and ntv are consistent with
// their field types. E.g. an int32 can be changed into an int64, but an int64 cannot
// into an int32. Indices that need to be recreated (for an int width change) are
// recorded in recreateIndices.
func (tx *Tx) checkTypes(otv, ntv *typeVersion, recreateIndices map[string]struct{}) error <span class="cov8" title="1">{
        for _, f := range ntv.Fields </span><span class="cov8" title="1">{
                for _, of := range otv.Fields </span><span class="cov8" title="1">{
                        if f.Name != of.Name </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">increase, err := of.Type.compatible(f.Type)
                        if err != nil </span><span class="cov8" title="1">{
                                return fmt.Errorf("%w: field %q: %s", ErrIncompatible, f.Name, err)
                        }</span>
                        <span class="cov8" title="1">if increase </span><span class="cov8" title="1">{
                                // Indices involving this field need to be recreated. The indices are packed with fixed widths.
                                for name, idx := range otv.Indices </span><span class="cov8" title="1">{
                                        for _, ifield := range idx.Fields </span><span class="cov8" title="1">{
                                                if ifield.Name == f.Name </span><span class="cov8" title="1">{
                                                        recreateIndices[name] = struct{}{}
                                                        break</span>
                                                }
                                        }
                                }
                        }
                        <span class="cov8" title="1">break</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// compatible returns if ft and nft's types are compatible (with recursive checks
// for maps/slices/structs). If not an error is returned. If they are, the first
// return value indicates if this is a field that needs it index recreated
// (currently for ints that are packed with fixed width encoding).
func (ft fieldType) compatible(nft fieldType) (bool, error) <span class="cov8" title="1">{
        need := func(incr bool, l ...kind) (bool, error) </span><span class="cov8" title="1">{
                for _, k := range l </span><span class="cov8" title="1">{
                        if nft.Kind == k </span><span class="cov8" title="1">{
                                return incr, nil
                        }</span>
                }
                <span class="cov8" title="1">return false, fmt.Errorf("%w: need %v have %v", ErrIncompatible, l, nft.Kind)</span>
        }

        <span class="cov8" title="1">k := ft.Kind
        nk := nft.Kind

        // We refuse to change pointers to non-pointers for composite types that have
        // fields with Nonzero set: nil values would become zero values.
        if ft.Ptr &amp;&amp; !nft.Ptr &amp;&amp; k == nk &amp;&amp; nft.hasNonzeroField(false) </span><span class="cov8" title="1">{
                // todo: we could verify all data is nonzero?
                return false, fmt.Errorf("%w: type changing from ptr to non-ptr cannot have nonzero fields", ErrIncompatible)
        }</span>

        <span class="cov8" title="1">switch k </span>{
        case kindBytes, kindBool, kindBinaryMarshal, kindString, kindFloat32, kindFloat64, kindTime:<span class="cov8" title="1">
                return need(false, ft.Kind)</span>
        case kindInt8:<span class="cov8" title="1">
                if nk == k </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
                <span class="cov8" title="1">return need(true, kindInt16, kindInt32, kindInt, kindInt64)</span>
        case kindInt16:<span class="cov8" title="1">
                if nk == k </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
                <span class="cov8" title="1">return need(true, kindInt32, kindInt, kindInt64)</span>
        case kindInt32, kindInt:<span class="cov8" title="1">
                if nk == k </span><span class="cov8" title="1">{
                        return false, nil
                }</span>
                <span class="cov8" title="1">return need(true, kindInt32, kindInt, kindInt64)</span>
        case kindInt64:<span class="cov8" title="1">
                return need(false, kindInt64)</span>
        case kindUint8:<span class="cov8" title="1">
                if nk == k </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
                <span class="cov8" title="1">return need(true, kindUint16, kindUint32, kindUint, kindUint64)</span>
        case kindUint16:<span class="cov8" title="1">
                if nk == k </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
                <span class="cov8" title="1">return need(true, kindUint32, kindUint, kindUint64)</span>
        case kindUint32, kindUint:<span class="cov8" title="1">
                if nk == k </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
                <span class="cov8" title="1">return need(true, kindUint32, kindUint, kindUint64)</span>
        case kindUint64:<span class="cov8" title="1">
                return need(false, kindUint64)</span>
        case kindMap:<span class="cov8" title="1">
                if nk != k </span><span class="cov8" title="1">{
                        return false, fmt.Errorf("map to %v: %w", nk, ErrIncompatible)
                }</span>
                <span class="cov8" title="1">if _, err := ft.MapKey.compatible(*nft.MapKey); err != nil </span><span class="cov8" title="1">{
                        return false, fmt.Errorf("map key: %w", err)
                }</span>
                <span class="cov8" title="1">if _, err := ft.MapValue.compatible(*nft.MapValue); err != nil </span><span class="cov8" title="1">{
                        return false, fmt.Errorf("map value: %w", err)
                }</span>
                <span class="cov8" title="1">return false, nil</span>
        case kindSlice:<span class="cov8" title="1">
                if nk != k </span><span class="cov8" title="1">{
                        return false, fmt.Errorf("slice to %v: %w", nk, ErrIncompatible)
                }</span>
                <span class="cov8" title="1">if _, err := ft.List.compatible(*nft.List); err != nil </span><span class="cov8" title="1">{
                        return false, fmt.Errorf("list: %w", err)
                }</span>
                <span class="cov8" title="1">return false, nil</span>
        case kindStruct:<span class="cov8" title="1">
                if nk != k </span><span class="cov8" title="1">{
                        return false, fmt.Errorf("struct to %v: %w", nk, ErrIncompatible)
                }</span>
                <span class="cov8" title="1">for _, nf := range nft.Fields </span><span class="cov8" title="1">{
                        for _, f := range ft.Fields </span><span class="cov8" title="1">{
                                if nf.Name == f.Name </span><span class="cov8" title="1">{
                                        _, err := f.Type.compatible(nf.Type)
                                        if err != nil </span><span class="cov8" title="1">{
                                                return false, fmt.Errorf("field %q: %w", nf.Name, err)
                                        }</span>
                                        <span class="cov8" title="1">break</span>
                                }
                        }
                }
                <span class="cov8" title="1">return false, nil</span>
        }
        <span class="cov0" title="0">return false, fmt.Errorf("internal error: missing case for kind %v", k)</span>
}

func (ft fieldType) hasNonzeroField(stopAtPtr bool) bool <span class="cov8" title="1">{
        if ft.Ptr &amp;&amp; stopAtPtr </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">switch ft.Kind </span>{
        case kindMap:<span class="cov0" title="0">
                return ft.List.hasNonzeroField(true)</span>
        case kindSlice:<span class="cov0" title="0">
                return ft.MapValue.hasNonzeroField(true)</span>
        case kindStruct:<span class="cov8" title="1">
                for _, f := range ft.Fields </span><span class="cov8" title="1">{
                        if f.Nonzero || f.Type.hasNonzeroField(true) </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package bstore

// StatsKV represent operations on the underlying BoltDB key/value store.
type StatsKV struct {
        Get    uint
        Put    uint // For Stats.Bucket, this counts calls of CreateBucket.
        Delete uint
        Cursor uint // Any cursor operation: Seek/First/Last/Next/Prev.
}

// Stats tracks DB/Tx/Query statistics, mostly counters.
type Stats struct {
        // Number of read-only or writable transactions. Set for DB only.
        Reads  uint
        Writes uint

        Bucket  StatsKV // Use of buckets.
        Records StatsKV // Use of records bucket for types.
        Index   StatsKV // Use of index buckets for types.

        // Operations that modify the database. Each record is counted, e.g.
        // for a query that updates/deletes multiple records.
        Get    uint
        Insert uint
        Update uint
        Delete uint

        Queries       uint   // Total queries executed.
        PlanTableScan uint   // Full table scans.
        PlanPK        uint   // Primary key get.
        PlanUnique    uint   // Full key Unique index get.
        PlanPKScan    uint   // Scan over primary keys.
        PlanIndexScan uint   // Scan over index.
        Sort          uint   // In-memory collect and sort.
        LastType      string // Last type queried.
        LastIndex     string // Last index for LastType used for a query, or empty.
        LastOrdered   bool   // Whether last scan (PK or index) use was ordered, e.g. for sorting or because of a comparison filter.
        LastAsc       bool   // If ordered, whether last index scan was ascending.
}

func (skv *StatsKV) add(n StatsKV) <span class="cov8" title="1">{
        skv.Get += n.Get
        skv.Put += n.Put
        skv.Delete += n.Delete
        skv.Cursor += n.Cursor
}</span>

func (skv *StatsKV) sub(n StatsKV) <span class="cov8" title="1">{
        skv.Get -= n.Get
        skv.Put -= n.Put
        skv.Delete -= n.Delete
        skv.Cursor -= n.Cursor
}</span>

func (st *Stats) add(n Stats) <span class="cov8" title="1">{
        st.Reads += n.Reads
        st.Writes += n.Writes

        st.Bucket.add(n.Bucket)
        st.Records.add(n.Records)
        st.Index.add(n.Index)

        st.Get += n.Get
        st.Insert += n.Insert
        st.Update += n.Update
        st.Delete += n.Delete

        st.Queries += n.Queries
        st.PlanTableScan += n.PlanTableScan
        st.PlanPK += n.PlanPK
        st.PlanUnique += n.PlanUnique
        st.PlanPKScan += n.PlanPKScan
        st.PlanIndexScan += n.PlanIndexScan
        st.Sort += n.Sort

        st.LastType = n.LastType
        st.LastIndex = n.LastIndex
        st.LastOrdered = n.LastOrdered
        st.LastAsc = n.LastAsc
}</span>

// Sub returns st with the counters from o subtracted.
func (st Stats) Sub(o Stats) Stats <span class="cov8" title="1">{
        st.Reads -= o.Reads
        st.Writes -= o.Writes

        st.Bucket.sub(o.Bucket)
        st.Records.sub(o.Records)
        st.Index.sub(o.Index)

        st.Get -= o.Get
        st.Insert -= o.Insert
        st.Update -= o.Update
        st.Delete -= o.Delete

        st.Queries -= o.Queries
        st.PlanTableScan -= o.PlanTableScan
        st.PlanPK -= o.PlanPK
        st.PlanUnique -= o.PlanUnique
        st.PlanPKScan -= o.PlanPKScan
        st.PlanIndexScan -= o.PlanIndexScan
        st.Sort -= o.Sort

        return st
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package bstore

import (
        "encoding"
        "errors"
        "fmt"
        "io"
        "io/fs"
        "os"
        "reflect"
        "sync"
        "time"

        bolt "github.com/etcd-io/bbolt"
)

var (
        ErrAbsent       = errors.New("absent") // If a function can return an ErrAbsent, it can be compared directly, without errors.Is.
        ErrZero         = errors.New("must be nonzero")
        ErrUnique       = errors.New("not unique")
        ErrReference    = errors.New("referential inconsistency")
        ErrMultiple     = errors.New("multiple results")
        ErrSeq          = errors.New("highest autoincrement sequence value reached")
        ErrType         = errors.New("unknown/bad type")
        ErrIncompatible = errors.New("incompatible types")
        ErrFinished     = errors.New("query finished")
        ErrStore        = errors.New("internal/storage error") // E.g. when buckets disappear, possibly by external users of the underlying BoltDB database.
        ErrParam        = errors.New("bad parameters")

        errTxClosed    = errors.New("transaction is closed")
        errNestedIndex = errors.New("struct tags index/unique only allowed at top-level structs")
)

var sanityChecks bool // Only enabled during tests.

// DB is a database storing Go struct values in an underlying bolt database.
// DB is safe for concurrent use, unlike a Tx or a Query.
type DB struct {
        bdb *bolt.DB

        // Read transaction take an rlock on types. Register can make changes and
        // needs a wlock.
        typesMutex sync.RWMutex
        types      map[reflect.Type]storeType
        typeNames  map[string]storeType // Go type name to store type, for checking duplicates.

        statsMutex sync.Mutex
        stats      Stats
}

// Tx is a transaction on DB.
//
// A Tx is not safe for concurrent use.
type Tx struct {
        db  *DB // If nil, this transaction is closed.
        btx *bolt.Tx

        bucketCache map[bucketKey]*bolt.Bucket

        stats Stats
}

// bucketKey represents a subbucket for a type.
type bucketKey struct {
        typeName string
        sub      string // Empty for top-level type bucket, otherwise "records", "types" or starting with "index.".
}

type index struct {
        Unique bool
        Name   string // Normally named after the field. But user can specify alternative name with "index" or "unique" struct tag with parameter.
        Fields []field

        tv *typeVersion
}

type storeType struct {
        Name    string       // Name of type as stored in database. Different from the current Go type name if the uses the "typename" struct tag.
        Type    reflect.Type // Type we parse into for new values.
        Current *typeVersion

        // Earlier schema versions. Older type versions can still be stored. We
        // prepare them for parsing into the reflect.Type. Some stored fields in
        // old versions may be ignored: when a later schema has removed the field,
        // that old stored field is considered deleted and will be ignored when
        // parsing.
        Versions map[uint32]*typeVersion
}

// note: when changing, possibly update func equal as well.
type typeVersion struct {
        Version       uint32              // First uvarint of a stored record references this version.
        OndiskVersion uint32              // Version of on-disk format. Currently always 1.
        Noauto        bool                // If true, the primary key is an int but opted out of autoincrement.
        Fields        []field             // Fields that we store. Embed/anonymous fields are kept separately in embedFields, and are not stored.
        Indices       map[string]*index   // By name of index.
        ReferencedBy  map[string]struct{} // Type names that reference this type. We require they are registered at the same time to maintain referential integrity.

        name         string
        referencedBy []*index            // Indexes (from other types) that reference this type.
        references   map[string]struct{} // Keys are the type names referenced. This is a summary for the references from Fields.
        embedFields  []embed             // Embed/anonymous fields, their values are stored through Fields, we keep them for setting values.

        fillPercent float64 // For "records" bucket. Set to 1 for append-only/mostly use as set with HintAppend, 0.5 otherwise.
}

// note: when changing, possibly update func equal as well.
// embed/anonymous fields are represented as type embed. The fields inside the embed type are of this type field.
type field struct {
        Name       string
        Type       fieldType
        Nonzero    bool
        References []string // Referenced fields. Only for the top-level struct fields, not for nested structs.
        Default    string   // As specified in struct tag. Processed version is defaultValue.

        // If not the zero reflect.Value, set this value instead of a zero value on insert.
        // This is always a non-pointer value. Only set for the current typeVersion
        // linked to a Go type.
        defaultValue reflect.Value

        // Only set if this typeVersion will parse this field. We check
        // structField.Type for non-nil before parsing this field. We don't parse it
        // if this field is no longer in the type, or if it has been removed and
        // added again in later schema versions.
        structField reflect.StructField

        indices map[string]*index
}

// embed is for embed/anonymous fields. the fields inside are represented as a type field.
type embed struct {
        Name        string
        Type        fieldType
        structField reflect.StructField
}

type kind int

const (
        kindInvalid kind = iota
        kindBytes
        kindBool
        kindInt
        kindInt8
        kindInt16
        kindInt32
        kindInt64
        kindUint
        kindUint8
        kindUint16
        kindUint32
        kindUint64
        kindFloat32
        kindFloat64
        kindMap
        kindSlice
        kindString
        kindTime
        kindBinaryMarshal
        kindStruct
)

var kindStrings = []string{
        "(invalid)",
        "bytes",
        "bool",
        "int",
        "int8",
        "int16",
        "int32",
        "int64",
        "uint",
        "uint8",
        "uint16",
        "uint32",
        "uint64",
        "float32",
        "float64",
        "map",
        "slice",
        "string",
        "time",
        "binarymarshal",
        "struct",
}

func (k kind) String() string <span class="cov8" title="1">{
        return kindStrings[k]
}</span>

type fieldType struct {
        Ptr              bool       // If type is a pointer.
        Kind             kind       // Type with possible Ptr deferenced.
        Fields           []field    // For kindStruct.
        MapKey, MapValue *fieldType // For kindMap.
        List             *fieldType // For kindSlice.
}

func (ft fieldType) String() string <span class="cov0" title="0">{
        s := ft.Kind.String()
        if ft.Ptr </span><span class="cov0" title="0">{
                return s + "ptr"
        }</span>
        <span class="cov0" title="0">return s</span>
}

// Options configure how a database should be opened or initialized.
type Options struct {
        Timeout   time.Duration // Abort if opening DB takes longer than Timeout.
        Perm      fs.FileMode   // Permissions for new file if created. If zero, 0600 is used.
        MustExist bool          // Before opening, check that file exists. If not, io/fs.ErrNotExist is returned.
}

// Open opens a bstore database and registers types by calling Register.
//
// If the file does not exist, a new database file is created, unless opts has
// MustExist set. Files are created with permission 0600, or with Perm from
// Options if nonzero.
//
// Only one DB instance can be open for a file at a time. Use opts.Timeout to
// specify a timeout during open to prevent indefinite blocking.
func Open(path string, opts *Options, typeValues ...any) (*DB, error) <span class="cov8" title="1">{
        var bopts *bolt.Options
        if opts != nil &amp;&amp; opts.Timeout &gt; 0 </span><span class="cov8" title="1">{
                bopts = &amp;bolt.Options{Timeout: opts.Timeout}
        }</span>
        <span class="cov8" title="1">var mode fs.FileMode = 0600
        if opts != nil &amp;&amp; opts.Perm != 0 </span><span class="cov8" title="1">{
                mode = opts.Perm
        }</span>
        <span class="cov8" title="1">if opts != nil &amp;&amp; opts.MustExist </span><span class="cov8" title="1">{
                if _, err := os.Stat(path); err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">bdb, err := bolt.Open(path, mode, bopts)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">typeNames := map[string]storeType{}
        types := map[reflect.Type]storeType{}
        db := &amp;DB{bdb: bdb, typeNames: typeNames, types: types}
        if err := db.Register(typeValues...); err != nil </span><span class="cov8" title="1">{
                bdb.Close()
                return nil, err
        }</span>
        <span class="cov8" title="1">return db, nil</span>
}

// Close closes the underlying database.
func (db *DB) Close() error <span class="cov8" title="1">{
        return db.bdb.Close()
}</span>

// Stats returns usage statistics for the lifetime of DB.  Stats are tracked
// first in a Query or a Tx. Stats from a Query are propagated to its Tx when
// the Query finishes. Stats from a Tx are propagated to its DB when the
// transaction ends.
func (db *DB) Stats() Stats <span class="cov8" title="1">{
        db.statsMutex.Lock()
        defer db.statsMutex.Unlock()
        return db.stats
}</span>

// Stats returns usage statistics for this transaction.
// When a transaction is rolled back or committed, its statistics are copied
// into its DB.
func (tx *Tx) Stats() Stats <span class="cov8" title="1">{
        return tx.stats
}</span>

// WriteTo writes the entire database to w, not including changes made during this transaction.
func (tx *Tx) WriteTo(w io.Writer) (n int64, err error) <span class="cov8" title="1">{
        return tx.btx.WriteTo(w)
}</span>

// return a bucket through cache.
func (tx *Tx) bucket(bk bucketKey) (*bolt.Bucket, error) <span class="cov8" title="1">{
        if tx.bucketCache == nil </span><span class="cov8" title="1">{
                tx.bucketCache = map[bucketKey]*bolt.Bucket{}
        }</span>
        <span class="cov8" title="1">b := tx.bucketCache[bk]
        if b != nil </span><span class="cov8" title="1">{
                return b, nil
        }</span>
        <span class="cov8" title="1">top := tx.bucketCache[bucketKey{bk.typeName, ""}]
        if top == nil </span><span class="cov8" title="1">{
                tx.stats.Bucket.Get++
                top = tx.btx.Bucket([]byte(bk.typeName))
                if top == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("%w: missing bucket for type %q", ErrStore, bk.typeName)
                }</span>
                <span class="cov8" title="1">tx.bucketCache[bucketKey{bk.typeName, ""}] = top</span>
        }
        <span class="cov8" title="1">if bk.sub == "" </span><span class="cov8" title="1">{
                return top, nil
        }</span>

        <span class="cov8" title="1">tx.stats.Bucket.Get++
        b = top.Bucket([]byte(bk.sub))
        if b == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%w: missing bucket %q for type %q", ErrStore, bk.sub, bk.typeName)
        }</span>
        <span class="cov8" title="1">tx.bucketCache[bk] = b
        return b, nil</span>
}

func (tx *Tx) typeBucket(typeName string) (*bolt.Bucket, error) <span class="cov8" title="1">{
        return tx.bucket(bucketKey{typeName, ""})
}</span>

func (tx *Tx) recordsBucket(typeName string, fillPercent float64) (*bolt.Bucket, error) <span class="cov8" title="1">{
        b, err := tx.bucket(bucketKey{typeName, "records"})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">b.FillPercent = fillPercent
        return b, nil</span>
}

func (tx *Tx) indexBucket(idx *index) (*bolt.Bucket, error) <span class="cov8" title="1">{
        return tx.bucket(bucketKey{idx.tv.name, "index." + idx.Name})
}</span>

// Drop removes a type and its data from the database.
// If the type is currently registered, it is unregistered and no longer available.
// If a type is still referenced by another type, eg through a "ref" struct tag,
// ErrReference is returned.
// If the type does not exist, ErrAbsent is returned.
func (db *DB) Drop(name string) error <span class="cov8" title="1">{
        return db.Write(func(tx *Tx) error </span><span class="cov8" title="1">{
                tx.stats.Bucket.Get++
                if tx.btx.Bucket([]byte(name)) == nil </span><span class="cov8" title="1">{
                        return ErrAbsent
                }</span>

                <span class="cov8" title="1">if st, ok := db.typeNames[name]; ok &amp;&amp; len(st.Current.referencedBy) &gt; 0 </span><span class="cov8" title="1">{
                        return fmt.Errorf("%w: type is still referenced", ErrReference)
                }</span> else<span class="cov8" title="1"> if ok </span><span class="cov8" title="1">{
                        for ref := range st.Current.references </span><span class="cov8" title="1">{
                                var n []*index
                                for _, idx := range db.typeNames[ref].Current.referencedBy </span><span class="cov8" title="1">{
                                        if idx.tv != st.Current </span><span class="cov0" title="0">{
                                                n = append(n, idx)
                                        }</span>
                                }
                                <span class="cov8" title="1">db.typeNames[ref].Current.referencedBy = n</span>
                        }
                        <span class="cov8" title="1">delete(db.typeNames, name)
                        delete(db.types, st.Type)</span>
                }

                <span class="cov8" title="1">tx.stats.Bucket.Delete++
                return tx.btx.DeleteBucket([]byte(name))</span>
        })
}

// Delete calls Delete on a new writable Tx.
func (db *DB) Delete(values ...any) error <span class="cov8" title="1">{
        return db.Write(func(tx *Tx) error </span><span class="cov8" title="1">{
                return tx.Delete(values...)
        }</span>)
}

// Get calls Get on a new read-only Tx.
func (db *DB) Get(values ...any) error <span class="cov8" title="1">{
        return db.Read(func(tx *Tx) error </span><span class="cov8" title="1">{
                return tx.Get(values...)
        }</span>)
}

// Insert calls Insert on a new writable Tx.
func (db *DB) Insert(values ...any) error <span class="cov8" title="1">{
        return db.Write(func(tx *Tx) error </span><span class="cov8" title="1">{
                return tx.Insert(values...)
        }</span>)
}

// Update calls Update on a new writable Tx.
func (db *DB) Update(values ...any) error <span class="cov8" title="1">{
        return db.Write(func(tx *Tx) error </span><span class="cov8" title="1">{
                return tx.Update(values...)
        }</span>)
}

var typeKinds = map[reflect.Kind]kind{
        reflect.Bool:    kindBool,
        reflect.Int:     kindInt,
        reflect.Int8:    kindInt8,
        reflect.Int16:   kindInt16,
        reflect.Int32:   kindInt32,
        reflect.Int64:   kindInt64,
        reflect.Uint:    kindUint,
        reflect.Uint8:   kindUint8,
        reflect.Uint16:  kindUint16,
        reflect.Uint32:  kindUint32,
        reflect.Uint64:  kindUint64,
        reflect.Float32: kindFloat32,
        reflect.Float64: kindFloat64,
        reflect.Map:     kindMap,
        reflect.Slice:   kindSlice,
        reflect.String:  kindString,
}

func typeKind(t reflect.Type) (kind, error) <span class="cov8" title="1">{
        if t.Kind() == reflect.Slice &amp;&amp; t.Elem().Kind() == reflect.Uint8 </span><span class="cov8" title="1">{
                return kindBytes, nil
        }</span>

        <span class="cov8" title="1">k, ok := typeKinds[t.Kind()]
        if ok </span><span class="cov8" title="1">{
                return k, nil
        }</span>

        <span class="cov8" title="1">if t == reflect.TypeOf(zerotime) </span><span class="cov8" title="1">{
                return kindTime, nil
        }</span>

        <span class="cov8" title="1">if reflect.PointerTo(t).AssignableTo(reflect.TypeOf((*encoding.BinaryMarshaler)(nil)).Elem()) </span><span class="cov8" title="1">{
                return kindBinaryMarshal, nil
        }</span>

        <span class="cov8" title="1">if t.Kind() == reflect.Struct </span><span class="cov8" title="1">{
                return kindStruct, nil
        }</span>
        <span class="cov8" title="1">return kind(0), fmt.Errorf("%w: unsupported type %v", ErrType, t)</span>
}

func typeName(t reflect.Type) (string, error) <span class="cov8" title="1">{
        tags, err := newStoreTags(t.Field(0).Tag.Get("bstore"), true)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">if name, err := tags.Get("typename"); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span> else<span class="cov8" title="1"> if name != "" </span><span class="cov8" title="1">{
                return name, nil
        }</span>
        <span class="cov8" title="1">return t.Name(), nil</span>
}

// Get value for a key. For insert a next sequence may be generated for the
// primary key.
func (tv typeVersion) keyValue(tx *Tx, rv reflect.Value, insert bool, rb *bolt.Bucket) ([]byte, reflect.Value, error) <span class="cov8" title="1">{
        f := tv.Fields[0]
        krv := rv.FieldByIndex(f.structField.Index)
        var seq bool
        if krv.IsZero() </span><span class="cov8" title="1">{
                if !insert </span><span class="cov0" title="0">{
                        return nil, reflect.Value{}, fmt.Errorf("%w: primary key can not be zero value", ErrParam)
                }</span>
                <span class="cov8" title="1">if tv.Noauto </span><span class="cov8" title="1">{
                        return nil, reflect.Value{}, fmt.Errorf("%w: primary key cannot be zero value without autoincrement", ErrParam)
                }</span>
                <span class="cov8" title="1">id, err := rb.NextSequence()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, reflect.Value{}, fmt.Errorf("next primary key: %w", err)
                }</span>
                <span class="cov8" title="1">switch f.Type.Kind </span>{
                case kindInt, kindInt8, kindInt16, kindInt32, kindInt64:<span class="cov8" title="1">
                        if krv.OverflowInt(int64(id)) </span><span class="cov0" title="0">{
                                return nil, reflect.Value{}, fmt.Errorf("%w: next primary key sequence does not fit in type", ErrSeq)
                        }</span>
                        <span class="cov8" title="1">krv.SetInt(int64(id))</span>
                case kindUint, kindUint8, kindUint16, kindUint32, kindUint64:<span class="cov8" title="1">
                        if krv.OverflowUint(id) </span><span class="cov8" title="1">{
                                return nil, reflect.Value{}, fmt.Errorf("%w: next primary key sequence does not fit in type", ErrSeq)
                        }</span>
                        <span class="cov8" title="1">krv.SetUint(id)</span>
                default:<span class="cov8" title="1">
                        // todo: should check this during register.
                        return nil, reflect.Value{}, fmt.Errorf("%w: unsupported autoincrement primary key type %v", ErrZero, f.Type.Kind)</span>
                }
                <span class="cov8" title="1">seq = true</span>
        } else<span class="cov8" title="1"> if !tv.Noauto &amp;&amp; insert </span><span class="cov8" title="1">{
                // We let user insert their own ID for our own autoincrement
                // PK. But we update the internal next sequence if the users's
                // PK is highest yet, so a future autoincrement insert will succeed.
                switch f.Type.Kind </span>{
                case kindInt, kindInt8, kindInt16, kindInt32, kindInt64:<span class="cov8" title="1">
                        v := krv.Int()
                        if v &gt; 0 &amp;&amp; uint64(v) &gt; rb.Sequence() </span><span class="cov8" title="1">{
                                if err := rb.SetSequence(uint64(v)); err != nil </span><span class="cov0" title="0">{
                                        return nil, reflect.Value{}, fmt.Errorf("%w: updating sequence: %s", ErrStore, err)
                                }</span>
                        }
                case kindUint, kindUint8, kindUint16, kindUint32, kindUint64:<span class="cov8" title="1">
                        v := krv.Uint()
                        if v &gt; rb.Sequence() </span><span class="cov8" title="1">{
                                if err := rb.SetSequence(v); err != nil </span><span class="cov0" title="0">{
                                        return nil, reflect.Value{}, fmt.Errorf("%w: updating sequence: %s", ErrStore, err)
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">k, err := packPK(krv)
        if err != nil </span><span class="cov8" title="1">{
                return nil, reflect.Value{}, err
        }</span>
        <span class="cov8" title="1">if seq </span><span class="cov8" title="1">{
                tx.stats.Records.Get++
                if rb.Get(k) != nil </span><span class="cov0" title="0">{
                        return nil, reflect.Value{}, fmt.Errorf("%w: internal error: next sequence value is already present", ErrUnique)
                }</span>
        }
        <span class="cov8" title="1">return k, krv, err</span>
}

// Read calls function fn with a new read-only transaction, ensuring transaction rollback.
func (db *DB) Read(fn func(*Tx) error) error <span class="cov8" title="1">{
        db.typesMutex.RLock()
        defer db.typesMutex.RUnlock()
        return db.bdb.View(func(btx *bolt.Tx) error </span><span class="cov8" title="1">{
                tx := &amp;Tx{db: db, btx: btx}
                tx.stats.Reads++
                defer tx.addStats()
                return fn(tx)
        }</span>)
}

// Write calls function fn with a new read-write transaction. If fn returns
// nil, the transaction is committed. Otherwise the transaction is rolled back.
func (db *DB) Write(fn func(*Tx) error) error <span class="cov8" title="1">{
        db.typesMutex.RLock()
        defer db.typesMutex.RUnlock()
        return db.bdb.Update(func(btx *bolt.Tx) error </span><span class="cov8" title="1">{
                tx := &amp;Tx{db: db, btx: btx}
                tx.stats.Writes++
                defer tx.addStats()
                return fn(tx)
        }</span>)
}

// lookup storeType based on name of rt.
func (db *DB) storeType(rt reflect.Type) (storeType, error) <span class="cov8" title="1">{
        st, ok := db.types[rt]
        if !ok </span><span class="cov8" title="1">{
                return storeType{}, fmt.Errorf("%w: %v", ErrType, rt)
        }</span>
        <span class="cov8" title="1">return st, nil</span>
}

// HintAppend sets a hint whether changes to the types indicated by each struct
// from values is (mostly) append-only.
//
// This currently sets the BoltDB bucket FillPercentage to 1 for efficient use
// of storage space.
func (db *DB) HintAppend(append bool, values ...any) error <span class="cov8" title="1">{
        db.typesMutex.Lock()
        defer db.typesMutex.Unlock()
        for _, v := range values </span><span class="cov8" title="1">{
                t := reflect.TypeOf(v)
                st, err := db.storeType(t)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">if append </span><span class="cov8" title="1">{
                        st.Current.fillPercent = 1.0
                }</span> else<span class="cov8" title="1"> {
                        st.Current.fillPercent = 0.5
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package bstore

import (
        "fmt"
        "strings"
)

type storeTags []string

func newStoreTags(tag string, isPK bool) (storeTags, error) <span class="cov8" title="1">{
        if tag == "" </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">l := strings.Split(tag, ",")
        for _, s := range l </span><span class="cov8" title="1">{
                w := strings.SplitN(s, " ", 2)
                switch w[0] </span>{
                case "noauto", "typename":<span class="cov8" title="1">
                        if !isPK </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("%w: cannot have tag %q for non-primary key", ErrType, w[0])
                        }</span>
                case "index", "unique", "default", "-":<span class="cov8" title="1">
                        if isPK </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("%w: cannot have tag %q on primary key", ErrType, w[0])
                        }</span>
                case "name", "nonzero", "ref":<span class="cov8" title="1"></span>
                default:<span class="cov8" title="1">
                        return nil, fmt.Errorf("%w: unknown store tag %q", ErrType, w[0])</span>
                }
        }
        <span class="cov8" title="1">return storeTags(l), nil</span>
}

func (t storeTags) Has(word string) bool <span class="cov8" title="1">{
        for _, s := range t </span><span class="cov8" title="1">{
                if s == word </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func (t storeTags) Get(word string) (string, error) <span class="cov8" title="1">{
        wordsp := word + " "
        for _, s := range t </span><span class="cov8" title="1">{
                if strings.HasPrefix(s, wordsp) </span><span class="cov8" title="1">{
                        r := s[len(wordsp):]
                        if r == "" </span><span class="cov8" title="1">{
                                return "", fmt.Errorf("%w: bstore word %q requires non-empty parameter", ErrType, word)
                        }</span>
                        <span class="cov8" title="1">return r, nil</span>
                } else<span class="cov8" title="1"> if s == word </span><span class="cov8" title="1">{
                        return "", fmt.Errorf("%w: bstore word %q requires argument", ErrType, word)
                }</span>
        }
        <span class="cov8" title="1">return "", nil</span>
}

func (t storeTags) List(word string) []string <span class="cov8" title="1">{
        var l []string
        wordsp := word + " "
        for _, s := range t </span><span class="cov8" title="1">{
                if strings.HasPrefix(s, wordsp) </span><span class="cov8" title="1">{
                        l = append(l, s[len(wordsp):])
                }</span>
        }
        <span class="cov8" title="1">return l</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package bstore

import (
        "bytes"
        "fmt"
        "reflect"

        bolt "github.com/etcd-io/bbolt"
)

func (tx *Tx) structptr(value any) (reflect.Value, error) <span class="cov8" title="1">{
        rv := reflect.ValueOf(value)
        if !rv.IsValid() || rv.Kind() != reflect.Ptr || !rv.Elem().IsValid() || rv.Type().Elem().Kind() != reflect.Struct </span><span class="cov8" title="1">{
                return reflect.Value{}, fmt.Errorf("%w: value must be non-nil pointer to a struct, is %T", ErrParam, value)
        }</span>
        <span class="cov8" title="1">rv = rv.Elem()
        return rv, nil</span>
}

func (tx *Tx) structOrStructptr(value any) (reflect.Value, error) <span class="cov8" title="1">{
        rv := reflect.ValueOf(value)
        if !rv.IsValid() </span><span class="cov8" title="1">{
                return reflect.Value{}, fmt.Errorf("%w: value must be non-nil if pointer", ErrParam)
        }</span>
        <span class="cov8" title="1">if rv.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                rv = rv.Elem()
                if !rv.IsValid() </span><span class="cov8" title="1">{
                        return rv, fmt.Errorf("%w: value must be non-nil if pointer", ErrParam)
                }</span>
        }
        <span class="cov8" title="1">if rv.Kind() != reflect.Struct </span><span class="cov8" title="1">{
                return reflect.Value{}, fmt.Errorf("%w: value must be a struct or pointer to a struct, is %T", ErrParam, value)
        }</span>
        <span class="cov8" title="1">return rv, nil</span>
}

// update indices by comparing indexed fields of the ov (old) and v (new). Only if
// the fields changed will the index be updated. Either ov or v may be the
// reflect.Value zero value, indicating there is no old/new value and the index
// should be updated.
func (tx *Tx) updateIndices(tv *typeVersion, pk []byte, ov, v reflect.Value) error <span class="cov8" title="1">{

        changed := func(idx *index) bool </span><span class="cov8" title="1">{
                for _, f := range idx.Fields </span><span class="cov8" title="1">{
                        rofv := ov.FieldByIndex(f.structField.Index)
                        nofv := v.FieldByIndex(f.structField.Index)
                        // note: checking the interface values is enough, we only allow comparable types as index fields.
                        if rofv.Interface() != nofv.Interface() </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
                <span class="cov8" title="1">return false</span>
        }

        <span class="cov8" title="1">for _, idx := range tv.Indices </span><span class="cov8" title="1">{
                var add, remove bool
                if !ov.IsValid() </span><span class="cov8" title="1">{
                        add = true
                }</span> else<span class="cov8" title="1"> if !v.IsValid() </span><span class="cov8" title="1">{
                        remove = true
                }</span> else<span class="cov8" title="1"> if !changed(idx) </span><span class="cov8" title="1">{
                        continue</span>
                } else<span class="cov8" title="1"> {
                        add, remove = true, true
                }</span>

                <span class="cov8" title="1">ib, err := tx.indexBucket(idx)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if remove </span><span class="cov8" title="1">{
                        _, ik, err := idx.packKey(ov, pk)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">tx.stats.Index.Delete++
                        if sanityChecks </span><span class="cov8" title="1">{
                                tx.stats.Index.Get++
                                if ib.Get(ik) == nil </span><span class="cov0" title="0">{
                                        return fmt.Errorf("internal error: key missing from index")
                                }</span>
                        }
                        <span class="cov8" title="1">if err := ib.Delete(ik); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("%w: removing from index: %s", ErrStore, err)
                        }</span>
                }
                <span class="cov8" title="1">if add </span><span class="cov8" title="1">{
                        prek, ik, err := idx.packKey(v, pk)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                        <span class="cov8" title="1">if idx.Unique </span><span class="cov8" title="1">{
                                tx.stats.Index.Cursor++
                                if xk, _ := ib.Cursor().Seek(prek); xk != nil &amp;&amp; bytes.HasPrefix(xk, prek) </span><span class="cov8" title="1">{
                                        return fmt.Errorf("%w: %q", ErrUnique, idx.Name)
                                }</span>
                        }

                        <span class="cov8" title="1">tx.stats.Index.Put++
                        if err := ib.Put(ik, []byte{}); err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("inserting into index: %w", err)
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func (tx *Tx) checkReferences(tv *typeVersion, pk []byte, ov, rv reflect.Value) error <span class="cov8" title="1">{
        for _, f := range tv.Fields </span><span class="cov8" title="1">{
                if len(f.References) == 0 </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">frv := rv.FieldByIndex(f.structField.Index)
                if frv.IsZero() || (ov.IsValid() &amp;&amp; ov.FieldByIndex(f.structField.Index).Interface() == frv.Interface()) </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">k, err := packPK(frv)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">for _, name := range f.References </span><span class="cov8" title="1">{
                        rb, err := tx.recordsBucket(name, tv.fillPercent)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">if rb.Get(k) == nil </span><span class="cov8" title="1">{
                                return fmt.Errorf("%w: value %v from field %q to %q", ErrReference, frv.Interface(), f.Name, name)
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func (tx *Tx) addStats() <span class="cov8" title="1">{
        tx.db.statsMutex.Lock()
        tx.db.stats.add(tx.stats)
        tx.db.statsMutex.Unlock()
        tx.stats = Stats{}
}</span>

// Get fetches records by their primary key from the database. Each value must
// be a pointer to a struct.
//
// ErrAbsent is returned if the record does not exist.
func (tx *Tx) Get(values ...any) error <span class="cov8" title="1">{
        if tx.db == nil </span><span class="cov8" title="1">{
                return errTxClosed
        }</span>

        <span class="cov8" title="1">for _, value := range values </span><span class="cov8" title="1">{
                tx.stats.Get++
                rv, err := tx.structptr(value)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">st, err := tx.db.storeType(rv.Type())
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">rb, err := tx.recordsBucket(st.Current.name, st.Current.fillPercent)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">k, _, err := st.Current.keyValue(tx, rv, false, rb)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">tx.stats.Records.Get++
                bv := rb.Get(k)
                if bv == nil </span><span class="cov8" title="1">{
                        return ErrAbsent
                }</span>
                <span class="cov8" title="1">if err := st.parse(rv, bv); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Delete removes values by their primary key from the database. Each value
// must be a struct or pointer to a struct. Indices are automatically updated
// and referential integrity is maintained.
//
// ErrAbsent is returned if the record does not exist.
// ErrReference is returned if another record still references this record.
func (tx *Tx) Delete(values ...any) error <span class="cov8" title="1">{
        if tx.db == nil </span><span class="cov8" title="1">{
                return errTxClosed
        }</span>

        <span class="cov8" title="1">for _, value := range values </span><span class="cov8" title="1">{
                tx.stats.Delete++
                rv, err := tx.structOrStructptr(value)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">st, err := tx.db.storeType(rv.Type())
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">rb, err := tx.recordsBucket(st.Current.name, st.Current.fillPercent)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">k, _, err := st.Current.keyValue(tx, rv, false, rb)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">tx.stats.Records.Get++
                bv := rb.Get(k)
                if bv == nil </span><span class="cov8" title="1">{
                        return ErrAbsent
                }</span>
                <span class="cov8" title="1">rov, err := st.parseNew(k, bv)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("parsing current value: %w", err)
                }</span>
                <span class="cov8" title="1">if err := tx.delete(rb, st, k, rov); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (tx *Tx) delete(rb *bolt.Bucket, st storeType, k []byte, rov reflect.Value) error <span class="cov8" title="1">{
        // Check that anyone referencing this type does not reference this record.
        for _, refBy := range st.Current.referencedBy </span><span class="cov8" title="1">{
                if ib, err := tx.indexBucket(refBy); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span> else<span class="cov8" title="1"> {
                        tx.stats.Index.Cursor++
                        if xk, _ := ib.Cursor().Seek(k); xk != nil &amp;&amp; bytes.HasPrefix(xk, k) </span><span class="cov8" title="1">{
                                return fmt.Errorf("%w: index %q", ErrReference, refBy.Name)
                        }</span>
                }
        }

        // Delete value from indices.
        <span class="cov8" title="1">if err := tx.updateIndices(st.Current, k, rov, reflect.Value{}); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("removing from indices: %w", err)
        }</span>

        <span class="cov8" title="1">tx.stats.Records.Delete++
        return rb.Delete(k)</span>
}

// Update updates records represented by values by their primary keys into the
// database. Each value must be a pointer to a struct. Indices are
// automatically updated.
//
// ErrAbsent is returned if the record does not exist.
func (tx *Tx) Update(values ...any) error <span class="cov8" title="1">{
        if tx.db == nil </span><span class="cov8" title="1">{
                return errTxClosed
        }</span>

        <span class="cov8" title="1">for _, value := range values </span><span class="cov8" title="1">{
                tx.stats.Update++
                rv, err := tx.structptr(value)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                <span class="cov8" title="1">st, err := tx.db.storeType(rv.Type())
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if err := tx.put(st, rv, false); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Insert inserts values as new records into the database. Each value must be a
// pointer to a struct. If the primary key field is zero and autoincrement is not
// disabled, the next sequence is assigned. Indices are automatically updated.
//
// ErrUnique is returned if the record already exists.
// ErrSeq is returned if no next autoincrement integer is available.
// ErrZero is returned if a nonzero constraint would be violated.
// ErrReference is returned if another record is referenced that does not exist.
func (tx *Tx) Insert(values ...any) error <span class="cov8" title="1">{
        if tx.db == nil </span><span class="cov8" title="1">{
                return errTxClosed
        }</span>

        <span class="cov8" title="1">for _, value := range values </span><span class="cov8" title="1">{
                tx.stats.Insert++
                rv, err := tx.structptr(value)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                <span class="cov8" title="1">st, err := tx.db.storeType(rv.Type())
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if err := st.Current.applyDefault(rv); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if err := tx.put(st, rv, true); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (tx *Tx) put(st storeType, rv reflect.Value, insert bool) error <span class="cov8" title="1">{
        rb, err := tx.recordsBucket(st.Current.name, st.Current.fillPercent)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">k, krv, err := st.Current.keyValue(tx, rv, insert, rb)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if insert </span><span class="cov8" title="1">{
                tx.stats.Records.Get++
                bv := rb.Get(k)
                if bv != nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("%w: record already exists", ErrUnique)
                }</span>
                <span class="cov8" title="1">return tx.insert(rb, st, rv, krv, k)</span>
        } else<span class="cov8" title="1"> {
                tx.stats.Records.Get++
                bv := rb.Get(k)
                if bv == nil </span><span class="cov8" title="1">{
                        return ErrAbsent
                }</span>
                <span class="cov8" title="1">ov, err := st.parseNew(k, bv)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("parsing current value: %w", err)
                }</span>
                <span class="cov8" title="1">return tx.update(rb, st, rv, ov, k)</span>
        }
}

func (tx *Tx) insert(rb *bolt.Bucket, st storeType, rv, krv reflect.Value, k []byte) error <span class="cov8" title="1">{
        v, err := st.pack(rv)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if err := tx.checkReferences(st.Current, k, reflect.Value{}, rv); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if err := tx.updateIndices(st.Current, k, reflect.Value{}, rv); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("updating indices for inserted value: %w", err)
        }</span>
        <span class="cov8" title="1">tx.stats.Records.Put++
        if err := rb.Put(k, v); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">rv.Field(0).Set(krv)
        return nil</span>
}

func (tx *Tx) update(rb *bolt.Bucket, st storeType, rv, rov reflect.Value, k []byte) error <span class="cov8" title="1">{
        if st.Current.equal(rov, rv) </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">v, err := st.pack(rv)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if err := tx.checkReferences(st.Current, k, rov, rv); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := tx.updateIndices(st.Current, k, rov, rv); err != nil </span><span class="cov8" title="1">{
                return fmt.Errorf("updating indices for updated record: %w", err)
        }</span>
        <span class="cov8" title="1">tx.stats.Records.Put++
        return rb.Put(k, v)</span>
}

// Begin starts a transaction.
//
// If writable is true, the transaction allows modifications.  Only one writable
// transaction can be active at a time on a DB. No read-only transactions can be
// active at the same time. Attempting to begin a read-only transaction from a
// writable transaction leads to deadlock.
//
// A writable Tx can be committed or rolled back. A read-only transaction must
// always be rolled back.
func (db *DB) Begin(writable bool) (*Tx, error) <span class="cov8" title="1">{
        tx, err := db.bdb.Begin(writable)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">db.typesMutex.RLock()
        if writable </span><span class="cov8" title="1">{
                db.stats.Writes++
        }</span> else<span class="cov8" title="1"> {
                db.stats.Reads++
        }</span>
        <span class="cov8" title="1">return &amp;Tx{db: db, btx: tx}, nil</span>
}

// Rollback aborts and cancels any changes made in this transaction.
// Statistics are added to its DB.
func (tx *Tx) Rollback() error <span class="cov8" title="1">{
        if tx.db == nil </span><span class="cov8" title="1">{
                return errTxClosed
        }</span>

        <span class="cov8" title="1">tx.addStats()
        tx.db.typesMutex.RUnlock()
        err := tx.btx.Rollback()
        tx.db = nil
        return err</span>
}

// Commit commits changes made in the transaction to the database.
// Statistics are added to its DB.
func (tx *Tx) Commit() error <span class="cov8" title="1">{
        if tx.db == nil </span><span class="cov8" title="1">{
                return errTxClosed
        }</span>

        <span class="cov8" title="1">tx.addStats()
        tx.db.typesMutex.RUnlock()
        err := tx.btx.Commit()
        if err != nil </span><span class="cov8" title="1">{
                tx.btx.Rollback() // Nothing to do for error.
        }</span>
        <span class="cov8" title="1">tx.db = nil
        return err</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
